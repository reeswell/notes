# Leetcode


- [Leetcode](#leetcode)
  - [栈和队列](#栈和队列)
      - [20. 有效的括号](#20-有效的括号)
      - [1190. 反转每对括号间的子串](#1190-反转每对括号间的子串)
      - [1249. 移除无效的括号](#1249-移除无效的括号)
      - [739. 每日温度](#739-每日温度)
      - [921. 使括号有效的最少添加](#921-使括号有效的最少添加)
      - [946. 验证栈序列](#946-验证栈序列)
  - [哈希表](#哈希表)
      - [1. 两数之和](#1-两数之和)
      - [15. 三数之和](#15-三数之和)
      - [242. 有效的字母异位词](#242-有效的字母异位词)
  - [贪心](#贪心)
      - [763. 划分字母区间](#763-划分字母区间)
  - [树](#树)
      - [98. 验证二叉搜索树](#98-验证二叉搜索树)
      - [100. 相同的树](#100-相同的树)
      - [101. 对称二叉树](#101-对称二叉树)
      - [104. 二叉树的最大深度](#104-二叉树的最大深度)
      - [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
      - [235. 二叉搜索树的最近公共祖先](#235-二叉搜索树的最近公共祖先)
      - [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
      - [108. 将有序数组转换为二叉搜索树](#108-将有序数组转换为二叉搜索树)
      - [110. 平衡二叉树](#110-平衡二叉树)
      - [111. 二叉树的最小深度](#111-二叉树的最小深度)
      - [112. 路径总和](#112-路径总和)
      - [113. 路径总和 II](#113-路径总和-ii)
      - [124. 二叉树中的最大路径和](#124-二叉树中的最大路径和)
      - [129. 求根节点到叶节点数字之和](#129-求根节点到叶节点数字之和)
      - [144. 二叉树的前序遍历](#144-二叉树的前序遍历)
      - [199. 二叉树的右视图](#199-二叉树的右视图)
      - [257. 二叉树的所有路径](#257-二叉树的所有路径)
      - [404. 左叶子之和](#404-左叶子之和)
      - [437. 路径总和 III](#437-路径总和-iii)
      - [450. 删除二叉搜索树中的节点](#450-删除二叉搜索树中的节点)
      - [501. 二叉搜索树中的众数](#501-二叉搜索树中的众数)
      - [543. 二叉树的直径](#543-二叉树的直径)
  - [二分查找](#二分查找)
  - [](#)
      - [69. x 的平方根 ](#69-x-的平方根-)
  - [动态规划](#动态规划)
      - [70. 爬楼梯](#70-爬楼梯)
      - [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
      - [ 62. 不同路径](#-62-不同路径)
      - [63. 不同路径 II](#63-不同路径-ii)
      - [198. 打家劫舍](#198-打家劫舍)
      - [213. 打家劫舍 II](#213-打家劫舍-ii)
      - [322. 零钱兑换](#322-零钱兑换)
  - [链表](#链表)
      - [142. 环形链表 II](#142-环形链表-ii)
      - [19. 删除链表的倒数第 N 个结点](#19-删除链表的倒数第-n-个结点)
      - [2. 两数相加](#2-两数相加)
      - [203. 移除链表元素](#203-移除链表元素)
      - [206. 反转链表](#206-反转链表)
      - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
      - [92. 反转链表 II](#92-反转链表-ii)
  - [双指针](#双指针)
      - [11. 盛最多水的容器](#11-盛最多水的容器)
      - [16. 最接近的三数之和](#16-最接近的三数之和)
      - [209. 长度最小的子数组](#209-长度最小的子数组)
      - [344. 反转字符串](#344-反转字符串)
      - [42. 接雨水](#42-接雨水)
      - [75. 颜色分类](#75-颜色分类)
      - [925. 长按键入](#925-长按键入)
  - [递归与回溯](#递归与回溯)
      - [面试题 16.11. 跳水板](#面试题-1611-跳水板)
      - [93. 复原 IP 地址](#93-复原-ip-地址)
      - [90. 子集 II](#90-子集-ii)
      - [79. 单词搜索](#79-单词搜索)
      - [78. 子集](#78-子集)
      - [73. 矩阵置零](#73-矩阵置零)
      - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii)
      - [54. 螺旋矩阵](#54-螺旋矩阵)
      - [51. N 皇后](#51-n-皇后)
      - [47. 全排列 II](#47-全排列-ii)
      - [46. 全排列](#46-全排列)
      - [784. 字母大小写全排列](#784-字母大小写全排列)
      - [40. 组合总和 II](#40-组合总和-ii)
      - [77. 组合](#77-组合)
      - [216. 组合总和 III](#216-组合总和-iii)
      - [131. 分割回文串](#131-分割回文串)
      - [面试题 08.08. 有重复字符串的排列组合](#面试题-0808-有重复字符串的排列组合)
      - [17. 电话号码的字母组合](#17-电话号码的字母组合)
      - [1291. 顺次数](#1291-顺次数)
      - [1219. 黄金矿工](#1219-黄金矿工)


## 栈和队列

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```js
// easy 解法1
var isValid = function (s) {
  // 如果是奇数，不可能匹配成功，直接返回false
  if (s.length & 1) return false;
  const stack = [];
  for (const c of s) {
    if (c === "(") stack.push(")");
    else if (c === "[") stack.push("]");
    else if (c === "{") stack.push("}");
    else {
      if (c !== stack.pop()) return false;
    }
  }
  return stack.length === 0;
};
// 解法2
var isValid2 = function (s) {
  // 如果是奇数，不可能匹配成功，直接返回false
  if (s.length & 1) return false;
  let stack = [];
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "(" || s[i] === "{" || s[i] === "[") stack.push(s[i]);
    else if (s[i] === ")" && stack[stack.length - 1] === "(") stack.pop();
    else if (s[i] === "}" && stack[stack.length - 1] === "{") stack.pop();
    else if (s[i] === "]" && stack[stack.length - 1] === "[") stack.pop();
    else return false;
  }
  return !stack.length;
};
```



#### [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

```js
// Medium
var reverseParentheses = function (s) {
  const stack = [""];
  for (const c of s) {
    if (c === "(") {
      stack.push("");
    } else if (c === ")") {
      const str = stack.pop().split("").reverse().join("");
      stack[stack.length-1] += str
    } else {
      stack[stack.length - 1] += c;
    }
  }
  return stack.pop()
};
```

#### [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

```js
// Medium
var minRemoveToMakeValid = function (s) {
    s = [...s]
    let stack = [];
    for (let i = 0; i < s.length; i++) {
        if (s[i] === "(")
            stack.push(i);
        else if (s[i] === ")") {
            if (stack.length) stack.pop();
            else s[i] = "";
        }
    }
    for (let i of stack) s[i] = "";
    return s.join("");
}
```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```js
// Medium
var dailyTemperatures = function (T) {
  let stack = [];
  // 初始化气温列表，默认值为0
  let res = new Array(T.length).fill(0);
  for (let i = 0; i < T.length; i++) {
    //将栈顶元素下标对应的值和当前元素进行比较
    while (stack.length && T[i] > T[stack[stack.length - 1]]) {
      let idx = stack.pop();
      res[idx] = i - idx;
    }
    stack.push(i);
  }
  return res;
};
```

#### [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

```js
// Medium
var minAddToMakeValid = function (s) {
  const stack = [];
  for (const c of s) {
    if (c === ")" && stack[stack.length - 1] === "(") stack.pop();
    else stack.push(c);
  }
  return stack.length;
};
```

#### [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

```js
// Medium
var validateStackSequences = function (pushed, popped) {
  let stack = [];
  for (let cur of pushed) {
    stack.push(cur);
    // 和出栈元素进行比对，如果匹配都弹出栈
    while (stack[stack.length - 1] === popped[0] && stack.length) {
      stack.pop();
      popped.shift();
    }
  }
  return !stack.length;
};
```

## 哈希表

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```js
// easy
var twoSum = function(nums, target) {
    let hash = {};
    for(let i = 0; i < nums.length; i++) {
        const n = nums[i];
        if(hash[target - n] !== undefined) {
            return [hash[target - n], i];
        }
        hash[n] = i;
    }
    return [];
}
// 解法2
var twoSum = function(nums, target) {
    let map = new Map();
    for(let i = 0; i < nums.length; i ++) {
        if(map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i];
        } else {
            map.set(nums[i], i);
        }
    }
    return [];
};
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```js
// Medium Map 和 Set
var threeSum = function(nums) {
    nums.sort((a,b) => a-b);
    let set = new Set(), res = [];
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === nums[i-1]) continue; 
        let m = new Map();
        for (let j = i+1; j < nums.length; j++) {
            if (j > 2 && nums[j] === nums[j-1]) continue;
            let sum = nums[i] + nums[j];
            if (m.has(-sum)) {
                set.add(`${nums[i]}#${-sum}#${nums[j]}`);
            }
            m.set(nums[j], j);
        }
    }
    for (let key of set) {
        res.push(key.split("#"));
    }
    return res;
    // Time Complexity: O(n^2)
    // Space Complexity: O(n)
};
// 解法2 双指针
function threeSum(nums: number[]): number[][] {
  nums.sort((a, b) => a - b)
  const res: number[][] = []
  for (let i = 0; i < nums.length; i++) {
    let low = i+1
    let high = nums.length - 1
    let sum = 0
    while (low < high) {
      sum = nums[i] + nums[low] + nums[high]
      if (sum < 0) {
        low++
      } else if (sum > 0) {
        high--
      } else {
        res.push([nums[i], nums[low], nums[high]])
        while (nums[low + 1] === nums[low]) low++
        while (nums[high - 1] === nums[high]) high--
        low++
        high--
      }
    }
    while (nums[i + 1] === nums[i]) i++
  }
  return res

};
```



#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```js
// easy
var isAnagram = function(s, t) {
    if (t.length !== s.length) return false;
    const counts = {};
    for (let c of s) {
        counts[c] = (counts[c] || 0) + 1;
    }
    for (let c of t) {
        if (!counts[c]) return false;
        counts[c]--;
    }
    return true;
};
```

## 贪心

#### [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

```js
// Medium
var partitionLabels = function (s) {
  let res = [];
  const hash = {};
  let max = -Infinity;
  let start = 0;
	// 记录每个字符的最大索引
  for (let i = 0; i < s.length; i++) {
    hash[s[i]] = i;
  }
  for (let i = 0; i < s.length; i++) {
    // 记录前面i个字符重复出现的最大索引
    max = Math.max(hash[s[i]], max);
    // 切割点
    if (max === i) {
      res.push(max - start + 1);
      start = i + 1;
    }
  }
  return res;
};
```



## 树

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```js
// Medium  利用中序遍历
var isValidBST = function(root) {

    function inOrder(node) {
        if(!node) return [];
        return [...inOrder(node.left), node.val, ...inOrder(node.right)]
    }

    const sortedArr = inOrder(root);

    for(let i = 0; i < sortedArr.length; i++) {
        if(sortedArr[i+1] <= sortedArr[i]) return false;
    }
    return true;
};
// 递归 左边存在比他小的值且比根节点小，右边存在比他大的值且比根节点大
var isValidBST = function(root, min=null, max=null) {
    if (!root) return true;
    if (min && root.val <= min.val) return false;
    if (max && root.val >= max.val) return false;
    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);
};
```

#### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```js
// easy dfs
var isSameTree = function (p, q) {
    const dfs = (left, right) => {
        if (left === null && right === null) return true
        if (left === null || right === null || left.val !== right.val) return false
        return dfs(left.left, right.left) && dfs(left.right, right.right)
    }
    return dfs(p, q)
}
// bfs
var isSameTree = function (p, q) {
    const queue = [[p,q]];
    while (queue.length) {
        const [p,q] = queue.shift();
        
        if (!p && !q) return true;
        if (!p || !q || p.val !== q.val) return false;
        
        if (p.left || q.left) queue.push([p.left, q.left]);
        if (p.right || q.right) queue.push([p.right, q.right]);
    }
    return true;
}
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```js
// easy dfs
var isSymmetric = function (root) {
    if (!root) return true
    let dfs = (left, right) => {
        if (!left && !right) return true
        if (!left || !right || left.val !== right.val) return false
        return dfs(left.left, right.right) && dfs(left.right, right.left)
    }
    return dfs(root.left, root.right)
}
//  bfs
var isSymmetric = function (root) {
    if (!root) return true
    let queue = [root.left, root.right]
    while (queue.length) {
        const left = queue.shift()
        const right = queue.shift()
        if (!left && !right) continue
        if (!left || !right || left.val !== right.val) return false
        else {
            queue.push(left.left, right.right)
            queue.push(left.right, right.left)
        }
    }
    return true
}
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```js
// easy dfs
var maxDepth = function (root) {
    if (!root) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
// bfs
var maxDepth = function (root) {
    if (!root) return 0
    let queue = [root]
    let deep = 0
    while (queue.length) {
        let size = queue.length
        while (size--) {
            let node = queue.shift()
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
        deep++
    }
    return deep
};
```



#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
// Medium dfs
var levelOrder = function (root) {
    if (!root) return []
    let res = []
    let dfs = (node, level) => {
        if (res[level]) res[level].push(node.val)
        else res[level] = [node.val]
        node.left && dfs(node.left, level + 1)
        node.right && dfs(node.right, level + 1)
    }
    dfs(root, 0)
    return res
};
// bfs
var levelOrder = function (root) {
    if (!root) return []
    let res = []
    let level = 0
    let queue = [root]
    while (queue.length) {
        let size = queue.length
        res.push([])
        while (size--) {
            let node = queue.shift()
            res[level].push(node.val)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        level++
    }
    return res
};
```

#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```js
// easy 迭代法
var lowestCommonAncestor = function(root, p, q) {
    while (root) {
        if (root.val < p.val && root.val < q.val) {
            root = root.right;
        }
        else if (root.val > p.val && root.val > q.val) {
            root = root.left;
        } else {
            return root;
        }
    }

};
// 递归法
var lowestCommonAncestor = function(root, p, q) {
    while (root) {
        if (root.val < p.val && root.val < q.val) {
            root = root.right;
        }
        else if (root.val > p.val && root.val > q.val) {
            root = root.left;
        } else {
            return root;
        }
    }

};
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```js
// Medium  dfs
const lowestCommonAncestor = (root, p, q) => {
    if (!root || root === p || root === q) return root
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    if (!left) return right  // p and q are in the right subtree
    if (!right) return left  // p and q are in the left subtree
    return root              // p is in one side and q is in the other
};

var BFS = function(root) {
    // If root is null return an empty array
    if(!root) return []
    const queue = [root] // initialize the queue with root
    const result = [] // declare output array

    while(queue.length !== 0){
       const queueLength = queue.length // Get the length prior to dequeueing
       for(let i = 0; i < queueLength; i++){
           const current = queue.shift()
           if(current.left){
               queue.push(current.left)
           }
           if(current.right){
               queue.push(current.right)
           }
           // After we add left and right for current, we add to currLevel
           result.push(current.val)
       }
   }
    return result
}
```

#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```js
// easy
var sortedArrayToBST = function(nums) {
    if (!nums.length) return null;
    const mid = Math.floor(nums.length / 2);
    const root = new TreeNode(nums[mid]);
    // subtrees are BSTs as well
    root.left = sortedArrayToBST(nums.slice(0, mid));
    root.right = sortedArrayToBST(nums.slice(mid + 1));
    return root;
};
```

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```js
// easy
var isBalanced = function(root) {
    let dfs = function(node) {
        if (!node) return 0;
        let left = 1 + dfs(node.left);
        let right = 1 + dfs(node.right);
        if (Math.abs(left - right) > 1) return Infinity;
        return Math.max(left, right);
    }
    
    return dfs(root)===Infinity?false:true;
};
```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```js
// easy dfs
var minDepth = function (root) {
  if (!root) return 0;
  if (!root.left) return minDepth(root.right) + 1;
  if (!root.right) return minDepth(root.left) + 1;
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};
// bfs
var minDepth = function (root) {
  if (!root) return [];
  let queue = [root];
  let depth = 1;
  while (queue[0]) {
    let size = queue.length;
    while (size--) {
      let curr = queue.shift(); // dequeue
      if (!curr.left && !curr.right) return depth;
      if (curr.left) queue.push(curr.left); // enqueue
      if (curr.right) queue.push(curr.right); // enqueue
    }
    depth++;
  }
};
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```js
// easy
var hasPathSum = function (root, targetSum) {
  if (!root) return false;
  let res = false;
  const dfs = (node, sum) => {
    sum -= node.val;
    if (sum === 0 && !node.left && !node.right) {
      res = true;
      return;
    }
    node.left && dfs(node.left, sum);
    node.right && dfs(node.right, sum);
  };
  dfs(root, targetSum);
  return res;
};
```

#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```js
// Medium
var pathSum = function(root, targetSum) {
  if (!root) return [];
  let res = [];
  let dfs = (cur, root, sum) => {
    // 拷贝一份
    cur = [...cur, root.val];
    sum -= root.val;
    if (!root.left && !root.right && sum == 0) {
      res.push(cur);
      return;
    }
    // 优先遍历左子树
    root.left && dfs(cur, root.left, sum);
    root.right && dfs(cur, root.right, sum);
  };
  dfs([], root, targetSum);
  return res;
};
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```js
// hard
var maxPathSum = function (root) {
  // let max = -Number.MAX_VALUE
  let max = Number.MIN_SAFE_INTEGER;
  function getMaxSum(node) {
    if (!node) return 0;
    var leftSum = getMaxSum(node.left);
    var rightSum = getMaxSum(node.right);
    max = Math.max(max, node.val + leftSum + rightSum);
    return Math.max(0, node.val + leftSum, node.val + rightSum);
  }
  getMaxSum(root);
  return max;
};
```

#### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```js
// 字符串拼接 最后+num转为数字
var sumNumbers1 = function (root) {
  function traverse(node, num) {
    if (!node) return null;
    num += node.val;
    if (!node.left && !node.right) return +num;
    return traverse(node.left, num) + traverse(node.right, num);
  }
  return traverse(root, "");
};
// 方法2
var sumNumbers = function (root) {
  let dfs = (cur, root) => {
    // 终止条件
    if (!root) return 0;
    // 计算当前节点的值
    cur = cur * 10 + root.val;
    // 找到一条路径，返回路径和
    if (!root.left && !root.right) {
      return cur;
    }
    // 对左右子树递归，求总和
    return dfs(cur, root.left) + dfs(cur, root.right);
  };
  return dfs(0, root);
};
// 方法3
var sumNumbers3 = function (root) {
  if (!root) return null;
  let sum = 0;
  function traverse(node, num) {
    num += node.val;
    if (!node.left && !node.right) sum += +num;
    if (node.left) traverse(node.left, num);
    if (node.right) traverse(node.right, num);
  }
  traverse(root, "");
  return sum;
};
```

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```js
// easy  dfs
var preorderTraversal = function (root) {
  if (!root) return [];
  const res = [];
  const dfs = (node) => {
    if (!node) return null;
    res.push(node.val);
    dfs(node.left);
    dfs(node.right);
  };
  dfs(root);
  return res;
};
// bfs
var preorderTraversal2 = function (root) {
  if (!root) return [];
  const res = [];
  const stack = [root];
  while (stack.length) {
    let size = stack.length;
    while (size--) {
      const node = stack.pop();
      res.push(node.val);
      node.right && stack.push(node.right);
      node.left && stack.push(node.left);
    }
  }
  return res;
};
```

#### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```js
// Medium dfs
var rightSideView = function (root) {
  if (!root) return [];
  let res = [];
  function pre(node, h) {
    if (!node) return;
    res[h] = node.val;
    pre(node.left, h + 1);
    pre(node.right, h + 1);
  }
  pre(root, 0);
  return res;
};
// bfs
var rightSideView = function (root) {
  if (!root) return [];
  let queue = [root];
  let res = [];
  while (queue.length) {
    let size = queue.length;
    res.push(queue[0].val);
    while (size--) {
      let node = queue.shift();
      // 优先放右孩子
      node.right && queue.push(node.right);
      node.left && queue.push(node.left);
    }
  }
  return res;
};
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```js
// easy
var binaryTreePaths = function (root) {
  if (!root) return [];
  const res = [];
  const dfs = (node, sum) => {
    if (!node) return;
    // 叶子节点直接不需要添加箭头并且把结果存起来
    if (!node.left && !node.right) {
      sum += node.val;
      res.push(sum);
      return;
    }
    sum += node.val + "->";
    dfs(node.left, sum);
    dfs(node.right, sum);
  };
  dfs(root, "");
  return res;
};
```

#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```js
// easy
var sumOfLeftLeaves = function(root) {
  if (!root) return 0;
  let sum = 0;
  const dfs = (node, isLeft) => {
    if (!node) return;
    if (!node.left && !node.right && isLeft) sum += node.val;
    dfs(node.left, true);
    dfs(node.right, false);
  };
  dfs(root, true);
  return sum;
};
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

```js
// Medium
var pathSum = function(root, targetSum) {
  // 定义一个计时器
  let cnt = 0;
  // 先序遍历所有根节点
  let preOrder = (root, sum) => {
    if (!root) return;
    dfs(root, sum);
    preOrder(root.left, sum);
    preOrder(root.right, sum);
  };
  let dfs = (root, sum) => {
    if (!root) return;
    sum -= root.val;
    // 求和满足，累加
    if (sum === 0) cnt++;
    // 递归左右子树，如果当前和为0了，但是下面还是有路，还是继续走下去
    // 因为本题数值范围存在负数，可能继续走下去还存在满足条件的路径
    dfs(root.left, sum);
    dfs(root.right, sum);
  };
  preOrder(root, targetSum);
  return cnt;
};
```

#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```js
// Medium
var deleteNode = function (root, key) {
  if (!root) return null;
  // 判断值是否小于root，小于走左子树，大于走右子树
  if (key < root.val) {
    root.left = deleteNode(root.left, key);
  } else if (key > root.val) {
    root.right = deleteNode(root.right, key);
  } else {
    // 1.如果删除节点没有左右子树，直接删除即可
    if (!root.left && !root.right) {
      root = null;
      // 2.如果删除节点仅有左孩子，直接指向左孩子
    } else if (root.left && !root.right) {
      root = root.left;
      // 3.如果删除节点仅有右孩子，直接指向右孩子
    } else if (!root.left && root.right) {
      root = root.right;
    } else {
      // 4.如果左右孩子都有，本代码采用方式是将前驱的最大值替换root的值
      let last = root.left;
      while (last.right) {
        last = last.right;
      }
      root.val = last.val;
      // 然后删除这个前驱最大值节点即可
      root.left = deleteNode(root.left, last.val);
    }
  }
  return root;
};
```

#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)



```js
// easy dfs
var findMode = function (root) {
  let cnt = 0; // 记录出现的次数
  let pre = 0; // 记录上一个数
  let res = [];
  let maxCnt = 0; // 记录当前出现最多的次数
  let handle = (cur) => {
    // 相同的数，累加
    if (cur === pre) {
      cnt++;
    } else {
      // 有新数出现，重新置计数器为1，更新新数
      pre = cur;
      cnt = 1;
    }
    // 如果次数超过了最大值，更新当前最大值
    if (cnt > maxCnt) {
      maxCnt = cnt;
      res = [cur];
      // 如果有相同频率的数字出现，直接加入
    } else if (cnt === maxCnt) {
      res.push(cur);
    }
  };
  // 二叉搜索树，递归中序遍历方式
  let inOrder = (root) => {
    if (!root) return null;
    inOrder(root.left);
    handle(root.val);
    inOrder(root.right);
  };
  inOrder(root);
  return res;
};
// bfs
var findMode2 = function (root) {
  const output = [];
  if (!root) return output;
  const obj = {};
  const queue = [root];
  let max = 0;

  while (queue.length) {
    const node = queue.shift();
    if (obj[node.val]) {
      obj[node.val] += 1;
    } else {
      obj[node.val] = 1;
    }

    if (obj[node.val] > max) max = obj[node.val];
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }

  for (let n in obj) {
    if (obj[n] === max) output.push(n);
  }

  return output;
};
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```js
// easy
var diameterOfBinaryTree = function (root) {
  if (!root) return 0;
  let res = 0;
  let dfs = (root) => {
    if (!root) return 0;
    // 后序遍历 先遍历左孩子
    let left = root.left && dfs(root.left) + 1;
    let right = root.right && dfs(root.right) + 1;
    // 每次求直径，比较左右孩子路径和的最大值
    res = Math.max(left + right, res);
    // 递归时候返回左右孩子深度最长
    return Math.max(left, right);
  };
  dfs(root);
  return res;
};
var diameterOfBinaryTree2 = function (root) {
  let diameter = 0;
  function dfs(node, level) {
    if (!node) return 0;

    const left = dfs(node.left);
    const right = dfs(node.right);
    // update diameter at every node
    diameter = Math.max(diameter, left + right);
    // update the largest number of edge so far
    return 1 + Math.max(left, right);
  }
  dfs(root);

  return diameter;
};
```



## 二分查找

## 

#### [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

```js
// easy
var mySqrt = function(x) {
  var left = 1;
  var right = Math.floor(x / 2) + 1;
  var mid;

  while (left <= right) {
    mid = Math.floor((left + right) / 2);

    if (mid * mid > x) {
      right = mid - 1;
    } else if (mid * mid < x) {
      left = mid + 1;
    } else {
      return mid;
    }
  }

  return right;
};
```

## 动态规划

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```js
// 解法1  easy
var climbStairs = function (n) {
    let dp = [0, 1, 2]
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
};
// 解法2
var climbStairs = function (n) {
    let pre = 0;
    let cur = 1;
    // let temp
    for (let i = 1; i <= n; i++) {
        // temp = pre;
        // pre = cur;
        // cur += temp;
        [pre, cur] = [cur, cur + pre]
    }
    return cur;
};
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 

```js
// easy
var maxProfit = function (prices) {
  const n = prices.length
  // 少于两天没有收益
  if(n < 2) return 0
  const dp = new Array(n)
  for (let i = 0; i < dp.length; i++) {
    // 每天都都有两个状态：持股、不持股
    dp[i] = new Array(2)
  }
  // 第一天不持股
  dp[0][0] = 0
  // 第一天持股
  dp[0][1] = -prices[0]
  for (let i = 1; i < n; i++) {
    // 第i天不持股，则前一天也不持股或者第i天卖出该股票
    dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i])
    // 第i天持股，则前一天也持股或者第i天买入该股票
    dp[i][1] = Math.max(dp[i-1][1],-prices[i])
  }
  // 最后一天卖出为受益最大
  return dp[n-1][0]
};
```



#### [ 62. 不同路径](https://leetcode-cn.com/problems/unique-paths/) 

```js
// Medium
var uniquePaths = function (m, n) {
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
  // 第一行和第一列只能有一个方向走
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1;
  }
  for (let j = 0; j < n; j++) {
    dp[0][j] = 1;
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
};
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) 

```js
// Medium
var uniquePathsWithObstacles = function (obstacleGrid) {
  const m = obstacleGrid.length;
  const n = obstacleGrid[0].length;
	// 出发点或终点者堵住返回0
  if (obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return 0;
  
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 起点不为1没被堵住设置路径为1
      if (i === 0 && j === 0) {
        obstacleGrid[i][j] = 1;
        continue;
      }
      // 值为0堵住了设置到达当前总计的路径为0
      if (obstacleGrid[i][j] === 1) {
        obstacleGrid[i][j] = 0;
        continue;
      }
      // 第一行的某一点的路径总和等于左边点的路径总和
      if (i === 0) {
        obstacleGrid[i][j] = obstacleGrid[i][j - 1];
        continue;
      }
      // 第一行的某一点的路径总和等于上边点的路径总和
      if (j === 0) {
        obstacleGrid[i][j] = obstacleGrid[i - 1][j];
        continue;
      }
      // 当前路径数等于左边路径数+上边路径数之和
      obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
    }
  }
  return obstacleGrid[m - 1][n - 1];
};
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) 

```js
// Medium
var rob = function (nums) {
  let n = nums.length;
  if (n === 0) return 0; 
  if (n === 1) return nums[0]; 
  if (n === 2) return Math.max(nums[0], nums[1]); 
  let dp = [];
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  
  for (let i = 2; i < n; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  }

  return Math.max(dp[n - 1], dp[n - 2]);
};
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/) 

```js
// Medium
var rob2 = function (nums) {
  // 对于长度为 0 和 1进行特判一下
  if (nums.length === 0) return 0;
  if (nums.length === 1) return nums[0];
  let arr1 = nums.slice();
  arr1.shift();
  let arr2 = nums.slice();
  arr2.pop();
  // 求不偷第一家房子和不偷最后一家房子的单向排列的最大值
  return Math.max(rob(arr1), rob(arr2));
};
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) 

```js
// Medium
var coinChange = function (coins, amount) {
const dp = Array(amount + 1).fill(Infinity); // This arr tells us how many coins we need for each amount.
  dp[0] = 0; // To make 0, we need 0 coins.
  for (let coin of coins) { // Check each coin
    for (let i = coin; i <= amount; i++) { // Iterate through the entire amount from coin
      dp[i] = Math.min(dp[i], dp[i - coin] + 1); // Update minimum number of needed coins.
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]; // If the last element is Infinity, then we cannot make the amount.
};
```

## 链表

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```js
// Medium
var detectCycle = function(head) {
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
};


var detectCycle = function (head) {
  let fast = head;
  let slow = head; // 首先，都从头节点出现
  while (fast) {
    // 确保存在环
    if (fast.next == null) return null; // fast.next 为null表示无环
    slow = slow.next; // 慢指针走一步
    fast = fast.next.next; // 快指针走两步
    if (slow === fast) {
      slow = head;
      while (slow !== fast) {
        slow = slow.next;
        fast = fast.next;
      }
      return slow;
    }
  }
  return null;
};
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```js
// Medium 解法1
var removeNthFromEnd = function (head, n) {
  let fast = head;
  let slow = head;
  //快指针先走
  while (n--) fast = fast.next; 
  //针对head = [1], n = 1
  if (!fast) return head.next; 
  while (fast.next) (fast = fast.next), (slow = slow.next);
  slow.next = slow.next.next;
  return head;
};
// 利用哑铃节点
var removeNthFromEnd = function (head, n) {
  let dummyHead = new ListNode();
  dummyHead.next = head;
  let p = dummyHead;
  let q = dummyHead;
  let k = n;
  // 先让一个指针先走n步
  while (k--) q = q.next; 
  while (q.next) {
    // 一起走
    q = q.next;
    p = p.next;
  }
  // 找到删除节点，进行删除
  p.next = p.next.next; 
  return dummyHead.next;
};
```

#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```js
// Medium
var addTwoNumbers = function (l1, l2) {
  var List = new ListNode(0);
  var head = List;
  var sum = 0;
  var carry = 0;

  while (l1 !== null || l2 !== null || sum > 0) {
    if (l1 !== null) {
      sum = sum + l1.val;
      l1 = l1.next;
    }
    if (l2 !== null) {
      sum = sum + l2.val;
      l2 = l2.next;
    }
    if (sum >= 10) {
      carry = 1;
      sum = sum - 10;
    }
    // 需要创建节点
    head.next = new ListNode(sum); 
    head = head.next;

    sum = carry;
    carry = 0;
  }

  return List.next;
};
```

#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```js
// easy
// 要对头结点进行操作时，考虑创建哑节点dummy，使用dummy->next表示真正的头节点。这样可以避免处理头节点为空的边界问题
// 在链表的操作中，添加一个哑节点（dummy node），让它的指针指向链表的头节点，这样在删除节点的时候，就不需要再判断删除的是否是头结点了
var removeElements = function (head, val) {
  let dummyHead = new ListNode(); // 哑结点
  dummyHead.next = head;
  let p = dummyHead;
  while (p.next) {
    if (p.next.val === val) {
      p.next = p.next.next;
    } else {
      p = p.next;
    }
  }
  return dummyHead.next;
};
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```js
// easy 循环解法
var reverseList = function (head) {
  let [pre, cur] = [null, head];
  while (cur) {
    [cur.next, pre, cur] = [pre, cur, cur.next];
    // let tmp = cur.next;
    // cur.next = pre;
    // pre = cur;
    // cur = tmp;
  }
  return pre;
};
// 递归解法
var reverseList = function (head) {
  const reverse = (pre, cur) => {
    if (!cur) return pre;
    let tmp = cur.next;
    cur.next = pre;
    return reverse(cur, tmp);
  };
  return reverse(null, head);
};
```

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```js
// Medium
var swapPairs = function (head) {
  if (!head || !head.next) return head;
  let v1 = head,
    v2 = head.next,
    v3 = v2.next;
  v2.next = v1;
  v1.next = swapPairs(v3);
  return v2;
};

var swapPairs = function (head) {
  // Store head to return list, Only instance of new data so space is O(1)
  let dummy = new ListNode(); // 虚拟节点
  dummy.next = head;

  let prev = dummy;

  // Traverse list
  while (head && head.next) {
    // Declare
    let n1 = head;
    let n2 = head.next;

    // Swap
    prev.next = n2;
    n1.next = n2.next;
    n2.next = n1;

    // Assign
    prev = n1;
    head = n1.next;
  }

  // The variable prev has been used to create the dummy list. dummy.next is still the head of new list
  return dummy.next;
};
```

#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```js
// Medium 递归
var reverseBetween = function (head, left, right) {
  let reverse = (pre, cur) => {
    if (!cur) return pre;
    let tmp = cur.next;
    cur.next = pre;
    return reverse(cur, tmp);
  };
  let dummyHead = new ListNode();
  dummyHead.next = head;
  let p = dummyHead;
  let k = left - 1;
  // 先找到需要反转链表部分的前驱节点
  while (k--) {
    p = p.next;
  }
  // 保存前驱节点
  let front = p;
  // 找到需要反转链表部分的头节点
  let frontNode = front.next;
  k = right - left + 1;
  // 再找到需要反转链表部分的尾节点
  while (k--) {
    p = p.next;
  }
  // 找到需要反转链表部分的尾节点
  let endNode = p;
  // 保存后继节点
  let end = endNode.next;
  // 将后继值为空，开始反转链表
  endNode.next = null;
  front.next = reverse(null, frontNode);
  // 原本的反转链表部分的头节点现在变成了尾节点，指向原本的后继节点
  frontNode.next = end;
  return dummyHead.next;
};
// 迭代
var reverseBetween = function (head, left, right) {
  let dummyHead = new ListNode();
  dummyHead.next = head;
  let p = dummyHead;
  let k = left - 1;
  // 先找到需要反转链表部分的前驱节点
  while (k--) {
    p = p.next;
  }
  // 保存前驱节点
  let front = p;
  let pre = (frontNode = front.next);
  let cur = pre.next;
  k = right - left;
  // 长度为3的链表需要反转2次，那么长度为n的链表需要反转n-1次
  while (k--) {
    let tmp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = tmp;
  }
  // 将原本前驱节点的next指向当前反转后的链表
  front.next = pre;
  // 原本反转链表的头节点现在变成了尾结点，指向后继节点
  frontNode.next = cur;
  return dummyHead.next;
};
```

## 双指针

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```typescript
// easy
function maxArea(height: number[]): number {
  let max = 0
  let area = 0
  let left = 0
  let right= height.length - 1 
  while (left < right) {
    if (height[left] < height[right]) {
      area = (right - left) * height[left]
      left++
    } else {
      area = (right - left) * height[right]
      right--
    }
    max = Math.max(area, max)
  }
  return max 
};
```

#### [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

```typescript
// Medium
function threeSumClosest(nums: number[], target: number): number {
  nums.sort((a, b) => a - b)
  let closest = Infinity
  for (let i = 0; i < nums.length -2; i++) {
    let left = i + 1
    let right = nums.length - 1
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right]
      if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum
      if (sum > target) {
        right--
      }
      else left++
    }
  }
  return closest
};
```

#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```js
// Medium
var minSubArrayLen = function (target, nums) {
  let len = nums.length;
  let L = 0;
  let R = 0;
  let res = Infinity;
  let sum = 0;
  while (R < len) {
    sum += nums[R];
    while (sum >= target) {
      // 滑动窗口
      res = Math.min(res, R - L + 1);
      sum -= nums[L];
      L++;
    }
    R++;
  }
  return res == Infinity ? 0 : res;
};
```

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```js
// easy
var reverseString = function (s) {
  let L = 0;
  let R = s.length - 1;
  while (L < R) {
    [s[L], s[R]] = [s[R], s[L]];
    L++;
    R--;
  }
  return s;
};
```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```js
// hard
var trap = function (height) {
  let len = height.length;
  let L = 0;
  let R = len - 1;
  let leftHeight = 0;
  let rightHeight = 0;
  let res = 0;
  while (L < R) {
    if (height[L] < height[R]) {
      leftHeight = Math.max(leftHeight, height[L]);
      res += leftHeight - height[L];
      L++;
    } else {
      // 右边高度小，看右边
      rightHeight = Math.max(rightHeight, height[R]);
      res += rightHeight - height[R];
      R--;
    }
  }
  return res;
};
```

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

```js
// Medium
var sortColors = function (nums) {
  let len = nums.length;
  let L = 0;
  let R = len - 1;
  let i = 0;
  while (i <= R) {
    if (nums[i] == 0) {
      // 当前值为0，那么就和左边指针进行交换
      [nums[i], nums[L]] = [nums[L], nums[i]];
      L++;
      i++;
    } else if (nums[i] == 2) {
      // 当前值为2，那么就和右边指针进行交换
      [nums[i], nums[R]] = [nums[R], nums[i]];
      R--;
    } else {
      i++;
    }
  }
  return nums;
};
```

#### [925. 长按键入](https://leetcode-cn.com/problems/long-pressed-name/)

```js
// easy
var isLongPressedName = function (name, typed) {
  let j = 0;
  for (let i = 0; i < typed.length; i++) {
    if (typed[i] === name[j]) {
      j++;
    } else if (typed[i] === name[j - 1]) {
      continue;
    } else {
      return false;
    }
  }
  return j === name.length;
};

```

## 递归与回溯

#### [面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)

```js
// easy
var divingBoard = function (shorter, longer, k) {
  if (k === 0) return [];
  if (shorter === longer) return [shorter * k];
  const res = [];
  for (let i = k; i >= 0; i--) {
    const result = i * shorter + (k - i) * longer;
    res.push(result);
  }
  return res;
};
```

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```js
// Medium
var restoreIpAddresses = function(s) {
  const res = [];
  const isValid = (str) => {
    if (+str > 255 || !str.length) return false;
    if (str.length >= 2 && str[0] === "0") return false;
    return true;
  };
  const permute = (arr, str) => {
    if (arr.length === 3) {
      if (isValid(str)) res.push([...arr, str]);
      return;
    }
    for (let i = 1; i < 4; i++) {
      let subStr = str.slice(0, i);
      if (!isValid(subStr)) continue;
      permute([...arr, subStr], str.slice(i));
    }
  };
  permute([], s);
  return res.map((x) => x.join("."));
};
```

#### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

```js
// Medium
var subsetsWithDup = function (nums) {
  const res = [];
  nums.sort((a, b) => a - b);
  const dfs = (arr, start) => {
    res.push(arr);
    for (let i = start; i < nums.length; i++) {
      if (i > start && nums[i - 1] === nums[i]) continue;
      arr.push(nums[i]);
      dfs([...arr], i + 1);
      arr.pop();
    }
  };
  dfs([], 0);
  return res;
};
// 解法2
var subsetsWithDup = function (nums) {
  const res = [];
  const dfs = (arr, start) => {
    res.push(arr);
    for (let i = start; i < nums.length; i++) {
      dfs([...arr, nums[i]], i + 1);
    }
  };
  dfs([], 0);
  return Array.from(new Set(res.map(JSON.stringify)), JSON.parse);
};
```

#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

```js
// Medium
var exist = function (board, word) {
  if (board.length === 0) return false;
  let dfs = (x, y, t) => {
    if (t === word.length) {
      return true;
    }
    // 剪枝条件
    if (
      x < 0 ||
      x >= board.length ||
      y < 0 ||
      y >= board[0].length ||
      board[x][y] != word[t] ||
      board[x][y] == "#"
    )
      return false;
    // 记录已走过的值
    let tmp = board[x][y];
    // 标记已走过的值
    board[x][y] = "#";
    // 从四个方向搜索，只要一个方向搜索有结果，那么直接返回 true即可
    let res =
      dfs(x + 1, y, t + 1) ||
      dfs(x, y + 1, t + 1) ||
      dfs(x - 1, y, t + 1) ||
      dfs(x, y - 1, t + 1);
    if (res) return true;
    // 回溯（重置）
    board[x][y] = tmp;
    return false;
  };
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      if (board[i][j] == word[0]) {
        let res = dfs(i, j, 0);
        if (res) return true;
      }
    }
  }
  return false;
};
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

```js
// Medium
var subsets2 = function (nums) {
  const res = [];
  const dfs = (start, arr) => {
    res.push(arr);
    for (let i = start; i < nums.length; i++) {
      dfs(i + 1, [...arr, nums[i]]);
      // 相当于下面三行
      // arr.push(nums[i]);
      // dfs(i + 1, [...arr]);
      // arr.pop();
    }
  };
  dfs(0, []);
  return res;
};
```

#### [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)



```js
// Medium
// 空间复杂度O(m * n)
var setZeroes = function (matrix) {
  const m = matrix.length;
  const n = matrix[0].length;
  let arr = [];
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (matrix[i][j] == 0) {
        arr.push([i, j]);
      }
    }
  }
  while (arr.length) {
    let [x, y] = arr.pop();
    for (let i = 0; i < m; i++) matrix[i][y] = 0;
    for (let j = 0; j < n; j++) matrix[x][j] = 0;
  }
  return matrix;
};
// 空间复杂度 O(1)
var setZeroes = function (matrix) {
  const m = matrix.length;
  const n = matrix[0].length;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (Object.is(matrix[i][j], 0)) {
        // 对行进行操作
        for (let k = 0; k < m; k++)
          if (!Object.is(matrix[k][j], 0) && k !== i) matrix[k][j] = -0;
        // 对列进行操作
        for (let k = 0; k < n; k++)
          if (!Object.is(matrix[i][k], 0) && k !== j) matrix[i][k] = -0;
      }
    }
  }
  return matrix;
};
```

#### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

```js
// Medium
var generateMatrix = function(n) {
  let top = 0;
  let left = 0;
  let right = n - 1;
  let bottom = n - 1;
  const res = [];
  for (let i = 0; i < n; i++) {
    res[i] = [];
  }
  let count = 1;
  const total = n * n;
  while (count <= total) {
    for (let i = left; i <= right; i++) res[top][i] = count++;
    top++;
    for (let i = top; i <= bottom; i++) res[i][right] = count++;
    right--;
    for (let i = right; i >= left; i--) res[bottom][i] = count++;
    bottom--;
    for (let i = bottom; i >= top; i--) res[i][left] = count++;
    left++;
  }
  return res;
};
```

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

```js
// Medium
var spiralOrder = function (matrix) {
  const res = [];
  while (matrix.length) {
    const first = matrix.shift();
    res.push(...first);
    for (const m of matrix) {
      let val = m.pop();
      if (val) res.push(val);
      m.reverse();
    }
    matrix.reverse();
  }
  return res;
};
// 解法2
var spiralOrder = function (matrix) {
  if (matrix.length === 0) return [];
  if (matrix[0].length === 0) return [];

  let result = [];
  // ADD FIRST ROW
  result = result.concat(matrix.shift());

  // ADD LAST COL
  for (let i = 0; i < matrix.length - 1; i++) {
    result.push(matrix[i].pop());
  }

  // ADD LAST ROW
  const lastRow = matrix.pop();
  if (lastRow) result = result.concat(lastRow.reverse());

  // ADD FIRST COL
  for (let i = matrix.length - 1; i >= 0; i--) {
    if (matrix[i].length) result.push(matrix[i].shift());
  }
  return result.concat(spiralOrder(matrix));
};
```

#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)



```js
// hard
var solveNQueens = function (n) {
  const res = [];
  const dfs = (arr, r) => {
    if (r === n) {
      res.push(arr.map((c) => ".".repeat(c) + "Q" + ".".repeat(n - c - 1)));
      return;
    }
    for (let i = 0; i < n; i++) {
      if (
        !arr.some(
          (item, index) =>
            item === i || item - r === i - index || item + r === i + index
        )
      ) {
        dfs([...arr, i], r + 1);
      }
    }
  };
  dfs([], 0);
  return res;
};
// 解法2
var solveNQueens = function (n) {
  let res = [];
  let grid = new Array(n); // 初始化一个地图
  for (let i = 0; i < n; i++) {
    grid[i] = new Array(n).fill(".");
  }
  // 剪枝条件
  let check = (x, y) => {
    for (let i = 0; i < x; i++) {
      for (let j = 0; j < n; j++) {
        // 判断同列 或者 同一斜线即可（不需要判断同行是因为一行一行放的，一定不同行）
        if (grid[i][j] == "Q" && (j == y || i + j == x + y || i - j == x - y)) {
          return true;
        }
      }
    }
    return false;
  };
  let dfs = (t) => {
    if (t === n) {
      let ans = grid.slice(); // 拷贝一份，对输出做处理
      for (let i = 0; i < n; i++) {
        ans[i] = ans[i].join("");
      }
      res.push(ans);
      return;
    }
    for (let i = 0; i < n; i++) {
      if (check(t, i)) continue;
      grid[t][i] = "Q";
      dfs(t + 1);
      grid[t][i] = ".";
    }
  };
  dfs(0);
  return res;
};
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```js
// Medium
var permuteUnique = function(nums) {
  nums.sort((a, b) => a - b);
  const res = [];
  const vis = {};
  const dfs = (arr) => {
    if (arr.length === nums.length) {
      res.push(arr);
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (i >= 1 && nums[i] === nums[i - 1] && vis[i - 1]) continue;
      if (vis[i]) continue;
      vis[i] = true;
      dfs([...arr, nums[i]], i + 1);
      vis[i] = false;
    }
  };
  dfs([]);
  return res;
};
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```js
// Medium
var permute = function (nums) {
  const res = [];
  const vis = {};
  const dfs = (arr) => {
    if (arr.length === nums.length) {
      res.push(arr);
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (vis[i]) continue;
      vis[i] = true;
      dfs([...arr, nums[i]], i + 1);
      vis[i] = false;
    }
  };
  dfs([]);
  return res;
};
```

#### [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

```js
// Medium
var letterCasePermutation = function(s) {
  let n = s.length;
  let res = [];
  let char = /[a-zA-Z]/;
  let arr = [];
  function backtrack(i) {
    if (i == n) {
      res.push(arr.join(""));
      return;
    }
    if (char.test(s[i])) {
      // 递归完小写字母然后递归大写字母
      arr[i] = s[i].toLowerCase();
      backtrack(i + 1);
      arr[i] = s[i].toUpperCase();
      backtrack(i + 1);
    } else {
      arr[i] = s[i];
      backtrack(i + 1);
    }
  }
  backtrack(0);
  return res;
};
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

```js
// Medium
var combinationSum2 = function(candidates, target) {
  candidates.sort((a, b) => a - b);
  const res = [];
  const dfs = (arr, sum, start) => {
    if (sum >= target) {
      if (sum === target) {
        res.push(arr);
      }
      return;
    }
    for (let i = start; i < candidates.length; i++) {
      if (i > start && candidates[i - 1] === candidates[i]) continue;
      dfs([...arr, candidates[i]], sum + candidates[i], i + 1);
    }
  };
  dfs([], 0, 0);
  return res;
};
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

```js
// Medium
var combine = function(n, k) {
 const res = []
  const dfs = (start,arr)=> {
    if(arr.length === k) {
      res.push(arr)
      return
    }
    for (let i = start; i <= n; i++) {
      dfs(i+1,[...arr,i])
    }
  }
  dfs(1,[])
  return res
};
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```js
// Medium
var combinationSum3 = function(k, n) {
  const res = [];
  const dfs = (start, arr,sum) => {
    if(sum > n) return;   
    if(arr.length === k) {
        if(sum === n) res.push(arr);
        return;
    }
    
    for (let i = start; i <= n; i++) {
      dfs(i + 1, [...arr, i],sum+i);
    }
  };
  dfs(1, [],0);
  return res;
};
```

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```js
// Medium
var partition = function(s) {
  const isPal = (str) => str === str.split("").reverse().join("");
  let res = [];
  let dfs = (arr, start) => {
    if (start === s.length) {
      res.push(arr);
      return;
    }
    for (let i = start; i < s.length; i++) {
      // 字符串切割
      let str = s.slice(start, i + 1);
      if (isPal(str)) {
        dfs([...arr, str], i + 1);
      }
    }
  };
  dfs([], 0);
  return res;
};
```

#### [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

```js
// Medium
var permutation = function (S) {
  const res = new Set();
  const vis = [];
  const dfs = (str) => {
    if (str.length === S.length) res.add(str);
    for (let i = 0; i < S.length; i++) {
      if (vis[i]) continue;
      vis[i] = true;
      dfs(str + S[i]);
      vis[i] = false;
    }
  };
  dfs("");
  return [...res];
};
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```js
// Medium
var letterCombinations = function(digits) {
  if (!digits.length) return [];
  const map = {
    2: "abc",
    3: "def",
    4: "ghi",
    5: "jkl",
    6: "mno",
    7: "pqrs",
    8: "tuv",
    9: "wxyz",
  };

  const res = [];
  const dfs = (start, s) => {
    if (start === digits.length) {
      res.push(s);
      return;
    }

    for (const c of map[digits[start]]) {
      dfs(start + 1, s + c);
    }
  };

  dfs(0, "");
  return res;
};
```

#### [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)

```js
// Medium 滑动窗口
var sequentialDigits = function (low, high) {
  const digits = "123456789";
  const ans = [];

  const minLen = low.toString().length;
  const maxLen = high.toString().length;

  for (let i = minLen; i <= maxLen; i++) {
    for (let j = 0; j + i <= digits.length; j++) {
      const num = parseInt(digits.substring(j, j + i));
      if (num >= low && num <= high) {
        ans.push(num);
      }
    }
  }
  return ans;
};

```

#### [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

```js
// Medium
var getMaximumGold = function (grid) {
  let count = 0;
  const maxGold = (grid, row = 0, col = 0, count = 0) => {
    if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0) {
      return count;
    } else if (grid[row][col] !== 0) {
      count += grid[row][col];
      let temp = grid[row][col];
      grid[row][col] = 0;
      let left = maxGold(grid, row - 1, col, count);
      let right = maxGold(grid, row + 1, col, count);
      let top = maxGold(grid, row, col - 1, count);
      let bottom = maxGold(grid, row, col + 1, count);
      grid[row][col] = temp;
      return Math.max(left, right, top, bottom);
    } else {
      return count;
    }
  };
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j] !== 0) count = Math.max(count, maxGold(grid, i, j));
    }
  }
  return count;
};
```

