## 目录

- [目录](#目录)
- [1.两数之和](#1两数之和)
- [2.两数相加](#2两数相加)
- [3.无重复字符的最长子串](#3无重复字符的最长子串)
- [4.寻找两个正序数组的中位数](#4寻找两个正序数组的中位数)
- [5.最长回文子串](#5最长回文子串)
- [10.正则表达式匹配](#10正则表达式匹配)
- [11.盛最多水的容器](#11盛最多水的容器)
- [15.三数之和](#15三数之和)
- [16.最接近的三数之和](#16最接近的三数之和)
- [17.电话号码的字母组合](#17电话号码的字母组合)
- [19.删除链表的倒数第-n-个结点](#19删除链表的倒数第-n-个结点)
- [20.有效的括号](#20有效的括号)
- [21.合并两个有序链表](#21合并两个有序链表)
- [22.括号生成](#22括号生成)
- [23.合并k个升序链表](#23合并k个升序链表)
- [31.下一个排列](#31下一个排列)
- [32.最长有效括号](#32最长有效括号)
- [33.搜索旋转排序数组](#33搜索旋转排序数组)
- [34.在排序数组中查找元素的第一个和最后一个位置](#34在排序数组中查找元素的第一个和最后一个位置)
- [42.接雨水](#42接雨水)
- [46.全排列](#46全排列)
- [48.旋转图像](#48旋转图像)
- [49.字母异位词分组](#49字母异位词分组)
- [53.最大子数组和](#53最大子数组和)
- [55.跳跃游戏](#55跳跃游戏)
- [56.合并区间](#56合并区间)
- [62.不同路径](#62不同路径)
- [63.不同路径-ii](#63不同路径-ii)
- [64.最小路径和](#64最小路径和)
- [67.二进制求和](#67二进制求和)
- [70.爬楼梯](#70爬楼梯)
- [72.编辑距离](#72编辑距离)
- [75.颜色分类](#75颜色分类)
- [78.子集](#78子集)
- [79.单词搜索](#79单词搜索)
- [94.二叉树的中序遍历](#94二叉树的中序遍历)
- [98.验证二叉搜索树](#98验证二叉搜索树)
- [101.对称二叉树](#101对称二叉树)
- [102.二叉树的层序遍历](#102二叉树的层序遍历)
- [104.二叉树的最大深度](#104二叉树的最大深度)
- [105.从前序与中序遍历序列构造二叉树](#105从前序与中序遍历序列构造二叉树)
- [114.二叉树展开为链表](#114二叉树展开为链表)
- [121.买卖股票的最佳时机](#121买卖股票的最佳时机)
- [128.最长连续序列](#128最长连续序列)
- [136.只出现一次的数字](#136只出现一次的数字)
- [139.单词拆分](#139单词拆分)
- [141.环形链表](#141环形链表)
- [142.环形链表-ii](#142环形链表-ii)
- [146.lru-缓存](#146lru-缓存)
- [148.排序链表](#148排序链表)
- [152.乘积最大子数组](#152乘积最大子数组)
- [155.最小栈](#155最小栈)
- [160.相交链表](#160相交链表)
- [167.两数之和-ii-输入有序数组](#167两数之和-ii-输入有序数组)
- [169.多数元素](#169多数元素)
- [198.打家劫舍](#198打家劫舍)
- [200.岛屿数量](#200岛屿数量)
- [206.反转链表](#206反转链表)
- [207.课程表](#207课程表)
- [208.实现-trie-前缀树](#208实现-trie-前缀树)
- [209.长度最小的子数组](#209长度最小的子数组)
- [215.数组中的第k个最大元素](#215数组中的第k个最大元素)
- [221.最大正方形](#221最大正方形)
- [226.翻转二叉树](#226翻转二叉树)
- [234.回文链表](#234回文链表)
- [236.二叉树的最近公共祖先](#236二叉树的最近公共祖先)
- [238.除自身以外数组的乘积](#238除自身以外数组的乘积)
- [239.滑动窗口最大值](#239滑动窗口最大值)
- [240.搜索二维矩阵-ii](#240搜索二维矩阵-ii)
- [242.有效的字母异位词](#242有效的字母异位词)
- [279.完全平方数](#279完全平方数)
- [283.移动零](#283移动零)
- [287.寻找重复数](#287寻找重复数)
- [300.最长递增子序列](#300最长递增子序列)
- [309.最佳买卖股票时机含冷冻期](#309最佳买卖股票时机含冷冻期)
- [322.零钱兑换](#322零钱兑换)
- [337.打家劫舍-iii](#337打家劫舍-iii)
- [338.比特位计数](#338比特位计数)
- [344.反转字符串](#344反转字符串)
- [347.前-k-个高频元素](#347前-k-个高频元素)
- [394.字符串解码](#394字符串解码)
- [399.除法求值](#399除法求值)
- [406.根据身高重建队列](#406根据身高重建队列)
- [416.分割等和子集](#416分割等和子集)
- [437.路径总和-iii](#437路径总和-iii)
- [438.找到字符串中所有字母异位词](#438找到字符串中所有字母异位词)
- [461.汉明距离](#461汉明距离)
- [494.目标和](#494目标和)
- [525.连续数组](#525连续数组)
- [538.把二叉搜索树转换为累加树](#538把二叉搜索树转换为累加树)
- [543.二叉树的直径](#543二叉树的直径)
- [560.和为-k-的子数组](#560和为-k-的子数组)
- [581.最短无序连续子数组](#581最短无序连续子数组)
- [617.合并二叉树](#617合并二叉树)
- [621.任务调度器](#621任务调度器)
- [647.回文子串](#647回文子串)
- [713.乘积小于-k-的子数组](#713乘积小于-k-的子数组)
- [739.每日温度](#739每日温度)
- [763.划分字母区间](#763划分字母区间)
- [921.使括号有效的最少添加](#921使括号有效的最少添加)
- [925.长按键入](#925长按键入)
- [946.验证栈序列](#946验证栈序列)
- [1190.反转每对括号间的子串](#1190反转每对括号间的子串)
- [1249.移除无效的括号](#1249移除无效的括号)
## 1.两数之和

```typescript
/*
 * @lc app=leetcode.cn id=1 lang=typescript
 *
 * [1] 两数之和
 */

// @lc code=start
function twoSum(nums: number[], target: number): number[] {
  const map = new Map()
  for (let i = 0; i < nums.length; i++) {
    if (!map.has(nums[i])) {
      map.set(target-nums[i],i)
    } else {
      return [map.get(nums[i]),i]
    }
  }
};
// @lc code=end
```

## 2.两数相加

```typescript
/*
 * @lc app=leetcode.cn id=2 lang=typescript
 *
 * [2] 两数相加
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null,carry=0): ListNode | null {
    if(l1||l2) {
      const next1 = getNextNode(l1)
      const next2 = getNextNode(l2)
      const sum = getNodeVal(l1) +  getNodeVal(l2) + carry
      const nextCarry = sum >= 10 ? 1 :0
      return new ListNode(sum % 10, addTwoNumbers(next1, next2, nextCarry))
    } else if(carry>0 ) {
      return new ListNode(1)
    }
    return null

};


function getNodeVal(l: ListNode | null):number {
  return l && l.val || 0
}

function getNextNode(l: ListNode | null):ListNode | null {
  return l && l.next || null;
}
// @lc code=end
```

## 3.无重复字符的最长子串

```typescript
/*
 * @lc app=leetcode.cn id=3 lang=typescript
 *
 * [3] 无重复字符的最长子串
 */

// @lc code=start
function lengthOfLongestSubstring(s: string): number {
  // if (s.length <= 1) return s.length
  // const map = new Map()
  // let left = 0
  // return s.split('').reduce((max, item, index) => {
  //   left = map.get(item) >= left ? map.get(item) + 1 : left
  //   map.set(item, index)
  //   return Math.max(max, index - left + 1)
  // }, 0)
  if (s.length<=1) return s.length
  let start = 0
  let left = 0
  let len = s.length
  let max = 0
  const map = new Map()
  while (left < len) {
    if (map.has(s[left])) {
      start = map.get(s[left]) + 1 >= start ? map.get(s[left]) + 1 : start
    }
    map.set(s[left], left)
    max = Math.max(max, left - start + 1)
    left++
  }
  return max
};
// @lc code=end
```

## 4.寻找两个正序数组的中位数

```typescript
/*
 * @lc app=leetcode.cn id=4 lang=typescript
 *
 * [4] 寻找两个正序数组的中位数
 */

// @lc code=start
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {

};
// @lc code=end
```

## 5.最长回文子串

```typescript
/*
 * @lc app=leetcode.cn id=5 lang=typescript
 *
 * [5] 最长回文子串
 */

// @lc code=start
function longestPalindrome(s: string): string {
  for (let j = s.length - 1; j >= 0; j--) {
    let i = 0,
      k = j;
    while (k < s.length) {
      let substr = s.substring(i, k + 1);
      if (isPalindrome(substr)) return substr;
      i++, k++;
    }
  }
  return "";
};
function isPalindrome(str) {
  let l = 0,
    r = str.length - 1;
  while (l < r) {
    if (str[l] !== str[r]) return false;
    l++, r--;
  }
  return true;
}
// @lc code=end
```

## 10.正则表达式匹配

```typescript
/*
 * @lc app=leetcode.cn id=10 lang=typescript
 *
 * [10] 正则表达式匹配
 */

// @lc code=start
function isMatch(s: string, p: string): boolean {

};
// @lc code=end
```

## 11.盛最多水的容器

```typescript
/*
 * @lc app=leetcode.cn id=11 lang=typescript
 *
 * [11] 盛最多水的容器
 */

// @lc code=start
function maxArea(height: number[]): number {
  let max = 0
  let area = 0
  let left = 0
  let right= height.length - 1 
  while (left < right) {
    if (height[left] < height[right]) {
      area = (right - left) * height[left]
      left++
    } else {
      area = (right - left) * height[right]
      right--
    }
    max = Math.max(area, max)
  }
  return max
    
};
// @lc code=end
```

## 15.三数之和

```typescript
/*
 * @lc app=leetcode.cn id=15 lang=typescript
 *
 * [15] 三数之和
 */

// @lc code=start
function threeSum(nums: number[]): number[][] {
  nums.sort((a, b) => a - b)
  const res: number[][] = []
  for (let i = 0; i < nums.length; i++) {
    let low = i+1
    let high = nums.length - 1
    let sum = 0
    while (low < high) {
      sum = nums[i] + nums[low] + nums[high]
      if (sum < 0) {
        low++
      } else if (sum > 0) {
        high--
      } else {
        res.push([nums[i], nums[low], nums[high]])
        while (nums[low + 1] === nums[low]) low++
        while (nums[high - 1] === nums[high]) high--
        low++
        high--
      }
    }
    while (nums[i + 1] === nums[i]) i++
  }
  return res

};
// @lc code=end
```

## 16.最接近的三数之和

```typescript
/*
 * @lc app=leetcode.cn id=16 lang=typescript
 *
 * [16] 最接近的三数之和
 */

// @lc code=start
function threeSumClosest(nums: number[], target: number): number {
  nums.sort((a, b) => a - b)
  let closest = Infinity
  for (let i = 0; i < nums.length -2; i++) {
    let left = i + 1
    let right = nums.length - 1
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right]
      if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum
      if (sum > target) {
        right--
      }
      else left++
    }
  }
  return closest
};
// @lc code=end
```

## 17.电话号码的字母组合

```typescript
/*
 * @lc app=leetcode.cn id=17 lang=typescript
 *
 * [17] 电话号码的字母组合
 */

// @lc code=start
function letterCombinations(digits: string): string[] {
  if (digits.length === 0) return []
  const res:string[] = []
  const values = {
    2: 'abc',
    3: 'def',
    4: 'ghi',
    5: 'jkl',
    6: 'mno',
    7: 'pqrs',
    8: 'tuv',
    9: 'wxyz',
  }
  const map = new Map<string, string>(Object.entries(values))

  const dfs = (start: number, str: string): void => {
    if (start === digits.length) {
      res.push(str)
      return
    }
    if (map.has(digits[start])) {
      for (const c of map.get(digits[start]) as string) { 
        dfs(start + 1, str + c)
      }
    }

  }
  dfs(0, '')
  return res
};
// @lc code=end
```

## 19.删除链表的倒数第-n-个结点

```typescript
/*
 * @lc app=leetcode.cn id=19 lang=typescript
 *
 * [19] 删除链表的倒数第 N 个结点
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
  let slow = head;
  let fast = head;
  // 快指针先走n步
  while (n--) {
    fast = fast.next;
  }
  // 针对head = [1], n = 1
  if (!fast) return head.next
  // 快慢指针一起走，快指针走到尽头时候慢指针的下一个结点就是要删除的结点
  while (fast.next) {
    fast = fast.next
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return head;
};
// @lc code=end
```

## 20.有效的括号

```typescript
/*
 * @lc app=leetcode.cn id=20 lang=typescript
 *
 * [20] 有效的括号
 */

// @lc code=start
function isValid(s: string): boolean {
  // 奇数直接返回false
  if(s.length & 1) return false;
  const stack:string[] = []
  for (const c of s) {
    if (c === '(') {
      stack.push(')')
    } else if (c === '[') {
      stack.push(']')
    } else if (c === '{') {
      stack.push('}')
    } else {
      if (c !== stack.pop()) return false
    }
  }
  return stack.length===0
};
// @lc code=end
```

## 21.合并两个有序链表

```typescript
/*
 * @lc app=leetcode.cn id=21 lang=typescript
 *
 * [21] 合并两个有序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
// 递归的方法更简洁，但如果链表很长，递归深度可能会导致栈溢出。因此，迭代方法是更好的选择。
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
  if(!list1) return list2;
  if(!list2) return list1;
  if (list1.val < list2.val) {
    list1.next = mergeTwoLists(list1.next, list2);
    return list1;
  } else {
    list2.next = mergeTwoLists(list1, list2.next);
    return list2;
  }
};

// function mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {
//   const dummyHead: ListNode | null = new ListNode();
//   let curr: ListNode | null = dummyHead;
//   while (l1 && l2) {
//     if (l1.val < l2.val) {
//       curr.next = l1;
//       l1 = l1.next;
//     } else {
//       curr.next = l2;
//       l2 = l2.next;
//     }
//     curr = curr.next;
//   }
//   curr.next = l1 || l2;
//   return dummyHead.next;
// };
// @lc code=end
```

## 22.括号生成

```typescript
/*
 * @lc app=leetcode.cn id=22 lang=typescript
 *
 * [22] 括号生成
 */

// @lc code=start
function generateParenthesis(n: number): string[] {
  const res:string[] = [];

  const dfs = (l:number,r:number,s:string) => {
    if (s.length === 2*n) {
      res.push(s);
      return
    }
    if (l < n) {
      dfs(l+1,r,s+'(');
    }
    if (r < l) {
      dfs(l,r+1,s+')');
    }
  }
  dfs(0,0,'');
  return res
};
// @lc code=end
```

## 23.合并k个升序链表

```typescript
/*
 * @lc app=leetcode.cn id=23 lang=typescript
 *
 * [23] 合并K个升序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
function mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {
  if (!l1) return l2;
  if (!l2) return l1;
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};

function helper(lists: Array<ListNode | null>, start: number, end: number): ListNode | null {
  if (start === end) {
    return lists[start];
  } else if (start < end) {
    parseInt
    const mid = Math.floor((end + start) / 2);
    const left = helper(lists, start, mid);
    const right = helper(lists, mid + 1, end);
    return mergeTwoLists(left, right);
  } else {
    return null;
  }
} 


function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
  return helper(lists, 0, lists.length - 1);
};
// @lc code=end
```

## 31.下一个排列

```typescript
/*
 * @lc app=leetcode.cn id=31 lang=typescript
 *
 * [31] 下一个排列
 */

// @lc code=start
/**
 Do not return anything, modify nums in-place instead.
 */            //pivot     
// E.g. [7, 2, 3, 1, 5, 4, 3, 2, 0]
function nextPermutation(nums: number[]): void {
  let i = nums.length - 2;
  // 找到基准索引i,这里例子的位置是1，这里确保i后面的数据到时从大到小排序了
  while (i >= 0 && nums[i + 1] <= nums[i]) {
    i--;
  }
  // 从后往前找，找到基准后面的数字比基准大的索引j，然后交互i,j位置
  // 变成 [7, 2, 3, 2, 5, 4, 3, 1, 0]
  if (i >= 0) {
    let j = nums.length - 1;
    while (j >= 0 && nums[j] <= nums[i]) {
      j--;
    }
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }
  // 基准索引后的元素反转
  reverse(nums, i + 1);
}

function reverse(nums: number[], start: number): void {
  let i = start, j = nums.length - 1;
  while (i < j) {
    [nums[i], nums[j]] = [nums[j], nums[i]];
    i++;
    j--;
  }
}

// @lc code=end
```

## 32.最长有效括号

```typescript
/*
 * @lc app=leetcode.cn id=32 lang=typescript
 *
 * [32] 最长有效括号
 */
// "()(()"
// @lc code=start
function longestValidParentheses(s: string): number {
  if(s.length<=1) return 0;
  let longest = 0
  // -1表示虚构索引假定开头有'(',
  let stack = [-1]
  for (let i = 0; i < s.length; i++) {
    let char = s[i]
    if (char === '(') {
      stack.push(i)
      continue
    }
    // )出栈，'))'这样开发的s字符串需要重新设定虚构虚构索引
    stack.pop()
    if (!stack.length) stack.push(i)
    else longest = Math.max((i - stack[stack.length - 1]), longest)
  }
  return longest
};
// @lc code=end
```

## 33.搜索旋转排序数组

```typescript
/*
 * @lc app=leetcode.cn id=33 lang=typescript
 *
 * [33] 搜索旋转排序数组
 */

// @lc code=start
function search(nums: number[], target: number): number {
  return nums.findIndex((item)=> item===target);
};

function search2(nums, target) {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    }
    // When dividing the roated array into two halves, one must be sorted.
    // Check if the left side is sorted
    if (nums[left] <= nums[mid]) {
      if (nums[left] <= target && target <= nums[mid]) {
        // target is in the left
        right = mid - 1;

      } else {
        // target is in the right
        left = mid + 1;
      }
    }

    // Otherwise, the right side is sorted
    else {
      if (nums[mid] <= target && target <= nums[right]) {
        // target is in the right
        left = mid + 1;

      } else {
        // target is in the left
        right = mid - 1;
      }
    }
  }

  return -1;
};
// @lc code=end
```

## 34.在排序数组中查找元素的第一个和最后一个位置

```typescript
/*
 * @lc app=leetcode.cn id=34 lang=typescript
 *
 * [34] 在排序数组中查找元素的第一个和最后一个位置
 */

// @lc code=start
function searchRange(nums: number[], target: number): number[] {
  let minIndex = binarySearch(nums, target, false);
  if (minIndex !== -1) {
    let maxIndex = binarySearch(nums, target, true);
    return [minIndex, maxIndex];
  }
  return [-1, -1];
}

function binarySearch(nums: number[], key: number, findMax: boolean) {
  let keyIndex = -1;

  let left = 0;

  let right = nums.length - 1;

  while (left <= right) {
    //  Math.floor(left + (right - left) / 2) 和 Math.floor((right +left) / 2) 相同好处是避免溢出
    let middle = Math.floor(left + (right - left) / 2);

    if (key > nums[middle]) {
      left = middle + 1;
    } else if (key < nums[middle]) {
      right = middle - 1;
    } else {
      // equal
      keyIndex = middle;

      if (findMax) {
        // true mean we are looking for max
        left = middle + 1;
      } else {
        // mean looking for min
        right = middle - 1;
      }
    }
  }
  return keyIndex
}
// @lc code=end
```

## 42.接雨水

```typescript
/*
 * @lc app=leetcode.cn id=42 lang=typescript
 *
 * [42] 接雨水
 */

// @lc code=start
function trap(height: number[]): number {
  let L = 0;
  let R = height.length - 1;
  let leftHeight = 0;
  let rightHeight = 0;
  let res = 0;
  while (L < R) {
    if (height[L] < height[R]) {
      leftHeight = Math.max(leftHeight, height[L]);
      res += leftHeight - height[L];
      L++;
    } else {
      // 右边高度小，看右边
      rightHeight = Math.max(rightHeight, height[R]);
      res += rightHeight - height[R];
      R--;
    }
  }
  return res;
};
// @lc code=end
```

## 46.全排列

```typescript
/*
 * @lc app=leetcode.cn id=46 lang=typescript
 *
 * [46] 全排列
 */

// @lc code=start
function permute(nums: number[]): number[][] {
  const res: number[][] = [];
  const dfs = (nums, curr, res)=> {
    if (curr.size == nums.length) {
      res.push(Array.from(curr));
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (curr.has(nums[i])) continue;
      curr.add(nums[i]);
      dfs(nums, curr, res);
      curr.delete(nums[i]);
    }
  }
  dfs(nums, new Set(), res);
  return res;
};


// @lc code=end
```

## 48.旋转图像

```typescript
/*
 * @lc app=leetcode.cn id=48 lang=typescript
 *
 * [48] 旋转图像
 */

// @lc code=start
/**
 Do not return anything, modify matrix in-place instead.
 */
function rotate(matrix: number[][]): void {
  for (let i = 0; i < matrix.length; i++) {
    for (let j = i; j < matrix[0].length; j++) {
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }
  for (let m of matrix) {
    m.reverse();
  }
};
// @lc code=end
```

## 49.字母异位词分组

```typescript
/*
 * @lc app=leetcode.cn id=49 lang=typescript
 *
 * [49] 字母异位词分组
 */

// @lc code=start
function groupAnagrams(strs: string[]): string[][] {
  if (strs.length === 1) return [strs]
  const hash = {}
  for (const str of strs) {
   const s = str.split('').sort().join('')
    if (hash[s]) hash[s] = [...hash[s], str]
    else hash[s] = [str]
  
  }
  return Object.values(hash)

};
// @lc code=end
```

## 53.最大子数组和

```typescript
/*
 * @lc app=leetcode.cn id=53 lang=typescript
 *
 * [53] 最大子数组和
 */

// @lc code=start
function maxSubArray(nums: number[]): number {
  let max = nums[0]
  for (let i = 1; i < nums.length; i++) {
    nums[i] = Math.max(0, nums[i - 1]) + nums[i]
    if (nums[i] > max) {
      max = nums[i]
    }
  }
  return max
};

// function maxSubArray2(nums: number[]): number {
//   const n = nums.length;
//   let curSum = nums[0];
//   let maxSum = nums[0];
//   for (let i = 1; i < n; i++) {
//     curSum = Math.max(nums[i], curSum + nums[i]);
//     maxSum = Math.max(maxSum, curSum);
//   }
//   return maxSum;
// };
// @lc code=end
```

## 55.跳跃游戏

```typescript
/*
 * @lc app=leetcode.cn id=55 lang=typescript
 *
 * [55] 跳跃游戏
 */

// @lc code=start
function canJump(nums: number[]): boolean {
  let idx = 0
  let max = 0
  let target = nums.length-1
  while (idx < nums.length) {
    max = Math.max(max, idx + nums[idx]) 
    if (max >= target) {
      return true
    }
    if (max <= idx && nums[idx] === 0) {
      return false
    }
    idx++
  }
  return false
};
// @lc code=end
```

## 56.合并区间

```typescript
/*
 * @lc app=leetcode.cn id=56 lang=typescript
 *
 * [56] 合并区间
 */

// @lc code=start
function merge(intervals: number[][]): number[][] {
  if(!intervals.length) return intervals
  intervals.sort((a, b) => a[0] - b[0])
  let prev = intervals[0]
  const res: number[][] = [prev]

  for (const cur of intervals) {
    if (cur[0] <= prev[1]) {
      prev[1] = Math.max(prev[1],cur[1])
    } else {
      res.push(cur)
      prev = cur
    }
  }
  return res
};
// @lc code=end
```

## 62.不同路径

```typescript
/*
 * @lc app=leetcode.cn id=62 lang=typescript
 *
 * [62] 不同路径
 */

// @lc code=start
function uniquePaths(m: number, n: number): number {
  const dp: number[][] = new Array(m).fill(0).map(() => new Array(n).fill(0))
  // 第一列只有一种走法，一直往下走
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1
  }
  // 第一行也只有一种走法，一直往右走
  for (let j = 0; j < n; j++) {
    dp[0][j] = 1
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }
  return dp[m - 1][n - 1]
};
// @lc code=end
```

## 63.不同路径-ii

```typescript
/*
 * @lc app=leetcode.cn id=63 lang=typescript
 *
 * [63] 不同路径 II
 */

// @lc code=start
function uniquePathsWithObstacles(obstacleGrid: number[][]): number {
  const m = obstacleGrid.length
  const n = obstacleGrid[0].length
  if (obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return 0
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i === 0 && j===0) {
        obstacleGrid[i][j] = 1
        continue
      }
      if (obstacleGrid[i][j] === 1) {
        obstacleGrid[i][j] = 0
        continue
      }
      // 第一行前面的路径可以为0或者为1，所以写成obstacleGrid[i][j-1]
      if (i===0) {
        obstacleGrid[i][j] = obstacleGrid[i][j-1]
        continue
      }
      // 第一列前面的路径可以为0或者为1，所以写成obstacleGrid[i][j-1]
      if (j === 0) {
        obstacleGrid[i][j] = obstacleGrid[i-1][j]
        continue
      }

      obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]
    }
    
  }
  return obstacleGrid[m-1][n-1]
  
};
// @lc code=end
```

## 64.最小路径和

```typescript
/*
 * @lc app=leetcode.cn id=64 lang=typescript
 *
 * [64] 最小路径和
 */

// @lc code=start
function minPathSum(grid: number[][]): number {
  const m = grid.length
  const n = grid[0].length
  // 第一列只有一种走法，一直往下走累积
  for (let i = 1; i < m; i++) {
    grid[i][0]+= grid[i-1][0]
    
  }
  // 第一列只有一种走法，一直往右走累积
  for (let j = 1; j < n; j++) {
    grid[0][j] += grid[0][j-1]
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      grid[i][j]+= Math.min(grid[i-1][j],grid[i][j-1])
    }
  }
  return grid[m-1][n-1]
};
// @lc code=end
```

## 67.二进制求和

```typescript
/*
 * @lc app=leetcode.cn id=67 lang=typescript
 *
 * [67] 二进制求和
 */

// @lc code=start
function addBinary(a: string, b: string): string {
  return (BigInt(`0B${a}`) + BigInt(`0B${b}`)).toString(2)
};
// @lc code=end
```

## 70.爬楼梯

```typescript
/*
 * @lc app=leetcode.cn id=70 lang=typescript
 *
 * [70] 爬楼梯
 */

// @lc code=start
function climbStairs(n: number): number {
  const dp = [1, 2, 3]
  for (let i = 3; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n - 1]
};
// @lc code=end
```

## 72.编辑距离

```typescript
/*
 * @lc app=leetcode.cn id=72 lang=typescript
 *
 * [72] 编辑距离
 */

// @lc code=start
function minDistance(word1: string, word2: string): number {

};
// @lc code=end
```

## 75.颜色分类

```typescript
/*
 * @lc app=leetcode.cn id=75 lang=typescript
 *
 * [75] 颜色分类
 */

// @lc code=start
/**
 Do not return anything, modify nums in-place instead.
 */
function sortColors(nums: number[]): void {
  let left = 0
  let right = nums.length - 1
  let i = 0
  while (i <= right) {
    if (nums[i] === 0) {
      [nums[i], nums[left]] = [nums[left], nums[i]]
      left++
      i++
    } else if (nums[i] === 2) {
      [nums[i], nums[right]] = [nums[right], nums[i]]
      right--
    } else {
      i++
    }
  }
};
// @lc code=end
```

## 78.子集

```typescript
/*
 * @lc app=leetcode.cn id=78 lang=typescript
 *
 * [78] 子集
 */

// @lc code=start
function subsets(nums: number[]): number[][] {
  const res:number[][] = []
  const dfs = (arr:number[],k:number) => {
    res.push(arr)
    for (let i = k; i < nums.length; i++) {
      dfs([...arr,nums[i]], i+1)
    }
  }
  dfs([], 0)
  return res
};
// @lc code=end
```

## 79.单词搜索

```typescript
/*
 * @lc app=leetcode.cn id=79 lang=typescript
 *
 * [79] 单词搜索
 */

// @lc code=start
function exist(board: string[][], word: string): boolean {
  let result = false
  const check = (r: number, c: number, i:number) => {
    if (!result) {
      if (r < 0 || c < 0 || r >= board.length || c >= board[0].length) return  // 超出边界
      if (board[r][c] !== word[i]) return // 不存在符合路径
      if (i === word.length - 1) { // 最后一个字母也相等意味着发现存在正确路径
        result = true
        return
      }
      board[r][c] = '#'  // 标记走过的路径
      check(r + 1, c, i + 1)
      check(r - 1, c, i + 1)
      check(r, c + 1, i + 1)
      check(r, c -1 , i + 1)

      board[r][c] = word[i] // 重置路径，否则会影响下一次迭代符合board[i][j] === word[0]) 的结果
    }

    
  }
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      if (board[i][j] === word[0]) {
        check(i, j, 0)
        if (result) return result
      }
    }
    
  }
  return result
};
// @lc code=end
```

## 94.二叉树的中序遍历

```typescript
/*
 * @lc app=leetcode.cn id=94 lang=typescript
 *
 * [94] 二叉树的中序遍历
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function inorderTraversal(root: TreeNode | null): number[] {
  if(!root) return []
  const res:number[] = []
  const dfs = (node: TreeNode | null) => {
    if (!node) return
    node.left && dfs(node.left)
    res.push(node.val)
    node.right && dfs(node.right)
  }
  dfs(root)
  return res
};

// function inorderTraversal(root: TreeNode | null): number[] {
//   if (root === null) return [];
//   return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];
// };
// 迭代
// function inorderTraversal(root) {
//   const stack = [];
//   const res = [];

//   while (root || stack.length) {
//     if (root) {
//       stack.push(root);
//       root = root.left;
//     } else {
//       root = stack.pop();
//       res.push(root.val);
//       root = root.right;
//     }
//   }

//   return res;
// }



// @lc code=end
```

## 98.验证二叉搜索树

```typescript
/*
 * @lc app=leetcode.cn id=98 lang=typescript
 *
 * [98] 验证二叉搜索树
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
// 利用中序遍历
function isValidBST(root: TreeNode | null): boolean {
  const inOrder = (node: TreeNode | null):number[] => {
    if (!node) return []
    return [...inOrder(node.left),node.val,...inOrder(node.right)]
  }
  const sortedArr = inOrder(root)
  for (let i = 0; i < sortedArr.length; i++) {
    if (sortedArr[i + 1] <= sortedArr[i]) {
      return false
    }
  }
  return true
};

// 递归 左边存在比他小的值且比根节点小，右边存在比他大的值且比根节点大
// function isValidBST2(root, min = null, max = null) {
//   if (!root) return true;
//   if (min && root.val <= min.val) return false;
//   if (max && root.val >= max.val) return false;
//   return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);
// };

// @lc code=end
```

## 101.对称二叉树

```typescript
/*
 * @lc app=leetcode.cn id=101 lang=typescript
 *
 * [101] 对称二叉树
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
// 递归
function isSymmetric(root: TreeNode | null): boolean {
  if (!root) return true
  const dfs = (left: TreeNode | null, right: TreeNode | null):boolean => {
    // 都为null则对称
    if (!left && !right) return true
    if (!left || !right || left.val !== right.val) return false
    return dfs(left.left,right.right) && dfs(left.right,right.left)
  }
  return dfs(root.left, root.right)
};
// 迭代
function isSymmetric2(root: TreeNode | null): boolean {
  if (!root) return true
  const queue = [root.left, root.right]
  while (queue.length) {
    const left = queue.shift()
    const right = queue.shift()
    if (!left && !right) continue
    if (!left || !right || left.val !== right.val) return false
    else {
      queue.push(left.left, right.right)
      queue.push(left.right,right.left)
    }
  }
  return true
};
// @lc code=end
```

## 102.二叉树的层序遍历

```typescript
/*
 * @lc app=leetcode.cn id=102 lang=typescript
 *
 * [102] 二叉树的层序遍历
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function levelOrder(root: TreeNode | null): number[][] {
  if (!root) return []

  const res:number[][] = []
  const dfs = (root: TreeNode | null,level:number) => {
    if (!root) return
    if (!res[level]) {
      res.push([root.val])
    } else {
      res[level].push(root.val)
    }
    root.left && dfs(root.left, level + 1)
    root.right && dfs(root.right, level + 1)
  }
  dfs(root, 0)
  return res
};

// function levelOrder(root: TreeNode | null): number[][] {
//   if (!root) return []
//   const res: number[][] = []

//   let level = 0
//   let queue = [root]
//   while (queue.length) {
//     let size = queue.length
//     res.push([])
//     while (size--) {
//       let node = queue.shift()
//       res[level].push(node.val)
//       node.left && queue.push(node.left)
//       node.right && queue.push(node.right)
//     }
//     level++
//   }
//   return res
// };
// @lc code=end
```

## 104.二叉树的最大深度

```typescript
/*
 * @lc app=leetcode.cn id=104 lang=typescript
 *
 * [104] 二叉树的最大深度
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function maxDepth(root: TreeNode | null): number {
  if(!root) return 0
  let max = 0
  const dfs = (node: TreeNode | null,depth:number) => {
    if (!node) return
    max = Math.max(max, depth)
    node.left && dfs(node.left, depth + 1)
    node.right && dfs(node.right, depth + 1)
  }
  dfs(root, 1)
  return max
};
// @lc code=end
```

## 105.从前序与中序遍历序列构造二叉树

```typescript
/*
 * @lc app=leetcode.cn id=105 lang=typescript
 *
 * [105] 从前序与中序遍历序列构造二叉树
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function buildTree(preorder: number[], inorder: number[]): TreeNode | null {
  if (!preorder.length || !inorder.length) return null
  const root = new TreeNode(preorder[0])
  const mid = inorder.indexOf(preorder[0])
  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid))
  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1))
  return root
};
// @lc code=end
```

## 114.二叉树展开为链表

```typescript
/*
 * @lc app=leetcode.cn id=114 lang=typescript
 *
 * [114] 二叉树展开为链表
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

/**
 Do not return anything, modify root in-place instead.
 */
function flatten(root: TreeNode | null): void {
  
};
// @lc code=end
```

## 121.买卖股票的最佳时机

```typescript
/*
 * @lc app=leetcode.cn id=121 lang=typescript
 *
 * [121] 买卖股票的最佳时机
 */

// @lc code=start
function maxProfit(prices: number[]): number {
  let profit = 0
  let min = prices[0]
  for (let i = 1; i < prices.length; i++) {
    if (min > prices[i]) {
      min = prices[i]
    } else if (prices[i] - min > profit) {
      profit = prices[i] - min
    }
  }
  return profit
}
// function maxProfit2(prices: number[]): number {
//   const n = prices.length
//   if(n<2) return 0
//   const dp = Array.from({length:n},()=> [0,0])
//   // 第一天不持有
//   dp[0][0] = 0
//   // 第一天持有
//   dp[0][1] = -prices[0]
//   for (let i = 1; i < n; i++) {
//     // 第i天不持有的最大值等于前一天不持有与前一天持有今天卖出
//     dp[i][0] = Math.max(dp[i - 1][1] + prices[i], dp[i-1][0])
//     // 第i天持有的最大值等于今天天持有与前一天持有今天不持有今天买入
//     dp[i][1] = Math.max(- prices[i], dp[i-1][1])
//   }
//   // 最后一天最大值为不持有
//   return dp[n-1][0]
// };
// @lc code=end
```

## 128.最长连续序列

```typescript
/*
 * @lc app=leetcode.cn id=128 lang=typescript
 *
 * [128] 最长连续序列
 */

// @lc code=start
function longestConsecutive(nums: number[]): number {
  if (!nums.length) return 0;
  const set = new Set(nums);
  let max = 0;
  for (let num of set) {
    if (set.has(num - 1)) continue;  // make sure starting from the beginning of sequence
    let currNum = num;
    let currMax = 1;
    while (set.has(currNum + 1)) {
      currNum++;
      currMax++;
    }
    max = Math.max(max, currMax);
  }
  return max;
};
// @lc code=end
```

## 136.只出现一次的数字

```typescript
/*
 * @lc app=leetcode.cn id=136 lang=typescript
 *
 * [136] 只出现一次的数字
 */

// @lc code=start
/**
* 按位异或操作是一种位运算，它可以对两个二进制数的每一位进行操作。按位异或操作的规则是：

当两个二进制位相同时，结果为0。
当两个二进制位不同时，结果为1。
对于本题中的输入数组，如果一个数字出现两次，那么它的二进制表示的每一位都是相同的。例如，对于数字2，它的二进制表示是10，所以它的每一位都是1和0。当我们对两个相同的数字进行按位异或操作时，它们的二进制表示的每一位都会变成0。因此，这些数字的按位异或操作的结果都是0。

如果我们将所有的数字进行按位异或操作，那么相同的数字将互相抵消，只留下只出现一次的数字。因为只出现一次的数字在按位异或操作中不会被抵消，所以最终的结果将是只出现一次的数字。


*/
function singleNumber(nums: number[]): number {
  let result = 0;
  for (let num of nums) {
    result ^= num;
  }
  return result;
};
// @lc code=end
```

## 139.单词拆分

```typescript
/*
 * @lc app=leetcode.cn id=139 lang=typescript
 *
 * [139] 单词拆分
 */

// @lc code=start
function wordBreak2(s: string, wordDict: string[]): boolean {
  if (!wordBreak.length) return false
  const visited = new Set()
  const set = new Set(wordDict)
  const queue:number[] = [0]
  while (queue.length) {
    const start = queue.shift() as number
    if (!visited.has(start)) {
      for (let end = start+1; end <= s.length; end++) {
        if (set.has(s.slice(start, end))) {
          if (end === s.length) return true
          queue.push(end)
        }
      }
      visited.add(start)
    }
  }
  return false
};

function wordBreak(s: string, wordDict: string[]): boolean {
  const n = s.length;
  const dp = new Array(n + 1).fill(false);
  dp[0] = true;

  for (let i = 1; i <= n; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }

  return dp[n];
}






// @lc code=end
```

## 141.环形链表

```typescript
/*
 * @lc app=leetcode.cn id=141 lang=typescript
 *
 * [141] 环形链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function hasCycle(head: ListNode | null): boolean {
  let slow = head
  let fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next
    fast = fast.next.next
    while (slow === fast) {
      return true
    }
  }
  return false
};
// @lc code=end
```

## 142.环形链表-ii

```typescript
/*
 * @lc app=leetcode.cn id=142 lang=typescript
 *
 * [142] 环形链表 II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function detectCycle(head: ListNode | null): ListNode | null {
  let fast = head;
  let slow = head;
  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
    if (fast === slow) {
      let p = head;
      while (p !== slow) {
        p = p.next;
        slow = slow.next;
      }
      return p;
    }
  }
  return null;
};
// @lc code=end
```

## 146.lru-缓存

```typescript
/*
 * @lc app=leetcode.cn id=146 lang=typescript
 *
 * [146] LRU 缓存
 */

// @lc code=start
class LRUCache {
    private capacity: number;
    private cache: Map<number, number>;
    constructor(capacity: number) {
        this.cache = new Map();
        this.capacity = capacity;
    }

    get(key: number): number {
        if (!this.cache.has(key)) return -1;

        const v = this.cache.get(key) as number;
        this.cache.delete(key);
        this.cache.set(key, v);
        return this.cache.get(key) as number;
    }

    put(key: number, value: number): void {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        }
        this.cache.set(key, value);
        if (this.cache.size > this.capacity) {
            this.cache.delete(this.cache.keys().next().value);  // keys().next().value returns first item's key
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
// @lc code=end
```

## 148.排序链表

```typescript
/*
 * @lc app=leetcode.cn id=148 lang=typescript
 *
 * [148] 排序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function sortList(head: ListNode | null): ListNode | null {
  if (!head || !head.next) return head

  // 将联表分成两半
  let slow = head
  let fast = head.next
  while (fast?.next) {
    slow = slow.next
    fast = fast.next.next
  }
  const mid = slow.next
  // 切断链表，避免循环引用
  slow.next = null

  // 递归排序两个子链表
  let left = sortList(head)
  let right = sortList(mid)

  // 两个链表从小到大排序
  const dummy = new ListNode(0)
  let cur = dummy
  while (left && right) {
    if (left.val < right.val) {
      cur.next = left
      left = left.next
    } else {
      cur.next = right
      right = right.next

    }
    cur = cur.next
  }
  cur.next = left || right
  return dummy.next
};
// @lc code=end
```

## 152.乘积最大子数组

```typescript
/*
 * @lc app=leetcode.cn id=152 lang=typescript
 *
 * [152] 乘积最大子数组
 */

// @lc code=start
function maxProduct(nums: number[]): number {
  if (nums.length === 1) return nums[0]
  const length = nums.length
  const dpMax: number[] = new Array(length)
  const dpMin: number[] = new Array(length)
  dpMax[0] = dpMin[0] = nums[0]
  let max = nums[0]
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] >= 0) {
      dpMax[i] = Math.max(nums[i], nums[i] * dpMax[i-1])
      dpMin[i] = Math.min(nums[i], nums[i] * dpMin[i - 1])
    } else {
      dpMax[i] = Math.max(nums[i], nums[i] * dpMin[i - 1])
      dpMin[i] = Math.min(nums[i], nums[i] * dpMax[i - 1])
    }
    max = Math.max(max, dpMax[i])
  }
  return max
};
// @lc code=end
```

## 155.最小栈

```typescript
/*
 * @lc app=leetcode.cn id=155 lang=typescript
 *
 * [155] 最小栈
 */

// @lc code=start
class MinStack {
    private stack: number[] = []
    private mixStack:number[] = []
    constructor() {

    }

    push(val: number): void {
        this.stack.push(val)
        if (this.mixStack.length === 0 || val <= this.getMin()) {
            this.mixStack.push(val)
        }
    }

    pop(): void {
        if (this.stack.pop() === this.getMin()) {
            this.mixStack.pop()
        }
    }

    top(): number {
       return this.stack[this.stack.length-1]
    }

    getMin(): number {
        return this.mixStack[this.mixStack.length-1]
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
// @lc code=end
```

## 160.相交链表

```typescript
/*
 * @lc app=leetcode.cn id=160 lang=typescript
 *
 * [160] 相交链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
  let pA: ListNode | null = headA
  let pB: ListNode | null = headB
  let lenA = 0
  let lenB = 0
  while (pA) {
    lenA++
    pA = pA.next
  }
  while (pB) {
    lenB++
    pB = pB.next
  }
  pA = headA
  pB = headB
  if (lenA > lenB) {
    for (let i = 0; i < lenA - lenB; i++) {
      pA = pA.next;
    }
  } else {
    for (let i = 0; i < lenB - lenA; i++) {
      pB = pB.next;
    }
  }
  while (pA && pB) {
    if (pA === pB) {
      return pA
    }
    pA = pA.next
    pB = pB.next
  }
  return null

};
// function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
//   let pA: ListNode = headA
//   let pB: ListNode = headB
// // 因为如果两个链表没有交点，最终两个指针都会指向 null，循环自然结束
//   while (pA !== pB) {
//     pA = pA === null ? headB : pA.next
//     pB = pB === null ? headA : pB.next
//   }
//   return pA
  
// };
// @lc code=end
```

## 167.两数之和-ii-输入有序数组

```typescript
/*
 * @lc app=leetcode.cn id=167 lang=typescript
 *
 * [167] 两数之和 II - 输入有序数组
 */

// @lc code=start
function twoSum(numbers: number[], target: number): number[] {
  const m = new Map()
  const res: number[] = []
  for (let i = 0; i < numbers.length; i++) {
    if (m.has(numbers[i])) {
      res.push(m.get(numbers[i]), i + 1)
    } else {
      m.set(target - numbers[i], i + 1)
    }

  }
  return res
};
// @lc code=end
```

## 169.多数元素

```typescript
/*
 * @lc app=leetcode.cn id=169 lang=typescript
 *
 * [169] 多数元素
 */

// @lc code=start
function majorityElement(nums: number[]): number {
  if (nums.length === 1) return nums[0]
  const map = new Map()
  let max = 0
  let res = nums[0]
  for (const n of nums) {
    if (!map.has(n)) {
      map.set(n,1)
    } else {
      map.set(n, map.get(n) + 1)
      if (map.get(n) > max) {
        max = map.get(n)
        res = n
      }
    }
  }
  return res
};

// function majorityElement(nums: number[]): number {
//   let candidate = 0;
//   let count = 0;
//   for (let num of nums) {
//     if (count === 0) {
//       candidate = num;
//     }
//     count += (num === candidate) ? 1 : -1;
//   }
//   return candidate;
// }
// @lc code=end
```

## 198.打家劫舍

```typescript
/*
 * @lc app=leetcode.cn id=198 lang=typescript
 *
 * [198] 打家劫舍
 */

// @lc code=start
function rob(nums: number[]): number {
  const n = nums.length
  if (n === 1) return nums[0]
  const dp: number[] = new Array(n)
  // 前一个房子只有一个，直接抢劫为金额最大
  dp[0] = nums[0]
  // 前两个房子抢劫金额的最大值
  dp[1] = Math.max(nums[0], nums[1])
  for (let i = 2; i < n; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
  }
  return dp[n - 1]
};
// @lc code=end
```

## 200.岛屿数量

```typescript
/*
 * @lc app=leetcode.cn id=200 lang=typescript
 *
 * [200] 岛屿数量
 */

// @lc code=start
function numIslands(grid: string[][]): number {
  const m = grid.length
  const n = grid[0].length
  let count = 0
  const dfs = (i:number,j:number) => {
    if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] === '0') return
    grid[i][j] = '0' // 重要，标志为已访问
    dfs(i - 1, j)
    dfs(i + 1, j)
    dfs(i, j - 1)
    dfs(i, j + 1)
  }
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === '1') {
        count++
        dfs(i, j)
      }
    }
  }
  return count
};
// @lc code=end
```

## 206.反转链表

```typescript
/*
 * @lc app=leetcode.cn id=206 lang=typescript
 *
 * [206] 反转链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
// easy 循环解法
function reverseList(head: ListNode | null): ListNode | null {
  let prev: ListNode | null = null
  let cur: ListNode | null = head
  while (cur) {
    [cur.next, prev, cur] = [prev,cur,cur.next]
  }
  return prev
};
// 递归解法
// function reverseList2(head) {
//   const reverse = (pre, cur) => {
//     if (!cur) return pre;
//     let tmp = cur.next;
//     cur.next = pre;
//     return reverse(cur, tmp);
//   };
//   return reverse(null, head);
// };
// @lc code=end
```

## 207.课程表

```typescript
/*
 * @lc app=leetcode.cn id=207 lang=typescript
 *
 * [207] 课程表
 */

// @lc code=start
function canFinish(numCourses: number, prerequisites: number[][]): boolean {
  // numCourses只有两个节点
  // 构建图，使用邻接表存储图，graph[i] 表示节点 i 所能到达的所有节点
  const graph: number[][] = new Array(numCourses).fill(0).map(() => [])
  // 记录每个节点的入度
  const inDegree: number[] = new Array(numCourses).fill(0)
  // 使用队列存储入度为 0 的节点
  const queue: number[] = []
  // let visited: number = 0
  for (const [course, prerequisiteCourse] of prerequisites) {
    // 记录先决条件的相邻节点
    graph[prerequisiteCourse].push(course);
    inDegree[course]++;
  }
  // 初始化队列,入度为0的先加入队列
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }
  // 循环遍历队列中的节点，直到队列为空
  while (queue.length > 0) {
    // 取出队列头部的节点
    const course = queue.shift()!;
    // 将已访问的节点数减 1
    numCourses--;
    // 遍历与当前节点相邻的节点
    for (const adjCourse of graph[course]) {
      // 将相邻节点的入度减 1
      if (--inDegree[adjCourse] === 0) {
        // 如果相邻节点的入度为 0，则将其加入队列
        queue.push(adjCourse);
      }
    }
  }
  // 如果所有课程都被访问过，则图中不存在环
  return numCourses === 0;
};
// @lc code=end
```

## 208.实现-trie-前缀树

```typescript
/*
 * @lc app=leetcode.cn id=208 lang=typescript
 *
 * [208] 实现 Trie (前缀树)
 */

// @lc code=start
class Trie {
    private node:TrieNode
    constructor() {
        this.node = new TrieNode()
        
    }
    insert(word: string): void {
        let node = this.node
        for (const ch of word) {
            if (!node.children.has(ch)) {
                node.children.set(ch,new TrieNode())
            }
            node = node.children.get(ch)!
        }   
        node.isEnd = true
    }

    search(word: string): boolean {
        let node = this.node
        for (const ch of word) {
            if (!node.children.has(ch)) {
                return false
            }
            node = node.children.get(ch)!
        }
        return node.isEnd
    }

    startsWith(prefix: string): boolean {
        let node = this.node
        for (const ch of prefix) {
            if (!node.children.has(ch)) {
                return false
            }
            node = node.children.get(ch)!
        }
        return true
    }
}

class TrieNode {
    children: Map<string, TrieNode>
    isEnd: boolean
    constructor() {
        this.children = new Map()
        this.isEnd = false
    }
    
}

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
// @lc code=end
```

## 209.长度最小的子数组

```typescript
/*
 * @lc app=leetcode.cn id=209 lang=typescript
 *
 * [209] 长度最小的子数组
 */

// @lc code=start
function minSubArrayLen(target: number, nums: number[]): number {
  let left = 0
  let right = 0
  let res = Infinity
  let sum= 0
  while (right < nums.length) {
    sum += nums[right]
    while (sum >= target) {
      res = Math.min(res, right - left + 1)
      sum -= nums[left]
      left++
    }
    right++
  }
  return res === Infinity ? 0 : res
};
// @lc code=end
```

## 215.数组中的第k个最大元素

```typescript
/*
 * @lc app=leetcode.cn id=215 lang=typescript
 *
 * [215] 数组中的第K个最大元素
 */

// @lc code=start

/**
 * 在数组中查找第 k 大的元素
 * @param nums 数组
 * @param k 第 k 大
 * @returns 第 k 大的元素
 */
function findKthLargest(nums: number[], k: number): number {
  // 调用快速选择算法查找第 k 大的元素
  // 数组长度减 k，因为我们要查找的是第 k 大的元素，而快速选择算法查找的是第 k 小的元素
  return quickSelect(nums, 0, nums.length - 1, nums.length - k)
};
/**
 * 使用快速选择算法查找第 k 小的元素
 * @param nums 数组
 * @param left 左边界
 * @param right 右边界
 * @param k 要查找的元素的下标
 * @returns 要查找的元素的值
 */
function quickSelect(nums: number[], left: number, right: number, k: number):number {
  // 对数组进行分区，返回分区点的下标

  const pivotIndex = partition(nums, left, right)
  // 如果分区点的下标等于要查找的元素的下标，说明找到了要查找的元素，直接返回该元素的值
  if (pivotIndex === k) {
    return nums[k]
  }
  // 如果分区点的下标小于要查找的元素的下标，说明要查找的元素在右半部分，递归调用 quickSelect 函数查找右半部分
  else if (pivotIndex < k) {
    return quickSelect(nums, pivotIndex + 1, right, k)
  }
  // 如果分区点的下标大于要查找的元素的下标，说明要查找的元素在左半部分，递归调用 quickSelect 函数查找左半部分
  else {
    return quickSelect(nums, left, pivotIndex - 1, k)
  }
}
/**
 * 将数组分成两部分，一部分是小于等于 pivot 的元素，另一部分是大于 pivot 的元素
 * @param nums 数组
 * @param left 左边界
 * @param right 右边界
 * @returns 分区点的下标
 */
function partition(nums: number[], left: number, right: number):number {
  // 取最后一个元素作为分区点
  let i = left
  const pivot = nums[right]
  // 从左往右遍历数组，将小于等于 pivot 的元素交换到左边
  for (let j = left; j < right; j++) {
    if (nums[j] <= pivot) {
      [nums[i], nums[j]] = [nums[j], nums[i]]
      i++
    }
  }
  // 将分区点交换到正确的位置
  [nums[i], nums[right]] = [nums[right], nums[i]]
  return i
}

// function quickSort(nums: number[]) {
//   if(nums.length<=1) return nums
//   let left: number[] = []
//   let right: number[] = []
//   // 选择第一个元素作为基准值
//   const pivot = nums[0]
//   for (let i = 1; i < nums.length; i++) {
//     if (nums[i] < pivot) {
//       left.push(nums[i])
//     } else {
//       right.push(nums[i])
//     }
//   }
//   return [...quickSort(left),pivot,...quickSort(right)]
// }

// @lc code=end
```

## 221.最大正方形

```typescript
/*
 * @lc app=leetcode.cn id=221 lang=typescript
 *
 * [221] 最大正方形
 */

// @lc code=start
function maximalSquare(matrix: string[][]): number {
  if (!matrix || matrix.length === 0) return 0;
  const m = matrix.length
  const n = matrix[0].length
  let maxLen = 0

  const dp = Array.from({ length: m }, () => new Array(n).fill(0));
  // copy matrix第一列的值到dp第一列 ，记录dp第一列的最大maxLen
  for (let i = 0; i < m; i++) {
    dp[i][0] = parseInt(matrix[i][0])
    maxLen = Math.max(maxLen, dp[i][0])

  }
  // copy matrix第一行的值到dp第一行，记录dp第一行的最大maxLen
  for (let j = 0; j < n; j++) {
    dp[0][j] = parseInt(matrix[0][j])
    maxLen = Math.max(maxLen, dp[0][j])
  }
  
  for (let i = 1; i < matrix.length; i++) {
    for (let j = 1; j < matrix[0].length; j++) {
      if (matrix[i][j] === '1') {
        // 记录左边、上边、左上角的最小值（最坏情况），加上当前的长度1
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
        maxLen = Math.max(maxLen, dp[i][j])
      }
      
    }
  }
  return maxLen * maxLen
};
// @lc code=end
```

## 226.翻转二叉树

```typescript
/*
 * @lc app=leetcode.cn id=226 lang=typescript
 *
 * [226] 翻转二叉树
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function invertTree(root: TreeNode | null): TreeNode | null {
  // 如果根节点为空，则返回 null
  if (!root) {
    return null;
  }

  // 保存当前节点的左子树
  const left = root.left;

  // 递归翻转当前节点的左右子树，并将左右子树交换
  root.left = invertTree(root.right);
  root.right = invertTree(left);

  // 返回翻转后的根节点
  return root;
};
// @lc code=end
```

## 234.回文链表

```typescript
/*
 * @lc app=leetcode.cn id=234 lang=typescript
 *
 * [234] 回文链表
 */


// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */
function isPalindrome(head: ListNode | null): boolean {
  if (!head || !head.next) {
    // 链表为空或只有一个节点，是回文链表
    return true;
  }
  // 快慢指针找到中点
  let slow = head
  let fast = head
  while (fast?.next?.next) {
    slow = slow.next
    fast = fast.next.next
  }
  // 从中间分两条链表
  let pre: ListNode | null = null
  let cur: ListNode | null = slow.next
  // 截断链表
  slow.next = null
  // 反转后半截链表
  while (cur) {
    [cur.next, pre, cur] = [pre, cur, cur.next]
  }
  let p1 = head
  let p2 = pre
  // 两条链表同时走
  while (p2) {
    if (p2.val !== p1.val) return false
    p2 = p2.next
    p1 = p1.next
  }
  return true
};

// function reverseList(head: ListNode | null): ListNode | null {
//   let pre: ListNode | null = null
//   let cur: ListNode | null = head
//   while (cur) {
//     [cur.next,pre,cur] = [pre,cur,cur.next]
//   }
//   return pre
// }

function isPalindrome2(head: ListNode | null): boolean {
  if (!head || !head.next) {
    // 链表为空或只有一个节点，是回文链表
    return true;
  }
  let str = ''
  while (head) {
    str += head.val
    head = head.next
  }
  return strIsPalindmore(str)
};

function strIsPalindmore(str: string):boolean {
  let start = 0
  let end = str.length - 1
  while (start<end) {
    if (str[start] !== str[end]) {
        return false
    }
    start++
    end--
  }
  return true
}
// @lc code=end
```

## 236.二叉树的最近公共祖先

```typescript
/*
 * @lc app=leetcode.cn id=236 lang=typescript
 *
 * [236] 二叉树的最近公共祖先
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  if (!root) return null; // 递归边界
  if (root === p || root === q) return root; // 如果当前节点为 p 或 q，则直接返回当前节点

  const left = lowestCommonAncestor(root.left, p, q); // 在左子树中查找 p 或 q
  const right = lowestCommonAncestor(root.right, p, q); // 在右子树中查找 p 或 q

  if (left && right) return root; // p 和 q 分别在左右子树中，返回当前节点
  return left || right; // p 和 q 在同一子树中，返回该子树的根节点
};


function lowestCommonAncestor2(root: TreeNode | null, p: TreeNode, q: TreeNode): TreeNode | null {
  if (!root) return null;

  const parentMap = new Map<TreeNode, TreeNode | null>();
  const queue: TreeNode[] = [root];

  // BFS 遍历树，将节点和它们的父节点映射到哈希表中
  while (queue.length) {
    const node = queue.shift()!;
    if (node.left) {
      parentMap.set(node.left, node);
      queue.push(node.left);
    }
    if (node.right) {
      parentMap.set(node.right, node);
      queue.push(node.right);
    }
  }

  const ancestors = new Set<TreeNode>();

  // 遍历 p 节点及其祖先节点，并将它们添加到祖先节点集合中
  while (p) {
    ancestors.add(p);
    p = parentMap.get(p)!;
  }

  // 遍历 q 节点及其祖先节点，查找是否存在与 p 相同的节点
  while (q) {
    if (ancestors.has(q)) {
      return q;
    }
    q = parentMap.get(q)!;
  }

  return null; // 没有找到最近公共祖先节点
}
// @lc code=end
```

## 238.除自身以外数组的乘积

```typescript
/*
 * @lc app=leetcode.cn id=238 lang=typescript
 *
 * [238] 除自身以外数组的乘积
 */

// @lc code=start
function productExceptSelf(nums: number[]): number[] {
  const n=  nums.length
  const res: number[] = []
  // 计算左边累计，num[i] = num[i-1]*[i-2]*[i-3]...
  let leftProduct = 1
  for (let i = 0; i < n; i++) {
    res[i] = leftProduct
    leftProduct *= nums[i]
  }
  // 计算右边累计，num[i] = num[i+1]*[i+2]*[i+3]...
  // 同时用左边累计与右边累计相乘既可，即num[i] = num[i-1]*[i-2]*[i-3]...*num[i+1]*[i+2]*[i+3]...
  let rightProduct = 1
  for (let i = n-1; i >= 0; i--) {
    res[i] *= rightProduct
    rightProduct *= nums[i]
  }
  return res
};
// @lc code=end
```

## 239.滑动窗口最大值

```typescript
/*
 * @lc app=leetcode.cn id=239 lang=typescript
 *
 * [239] 滑动窗口最大值
 */

// @lc code=start

function maxSlidingWindow(nums: number[], k: number): number[] {
  const result: number[] = [];
  const deque: number[] = []; // 双端队列，用于存放下标

  for (let i = 0; i < nums.length; i++) {
    // 保证 deque 中下标对应的元素是单调递减的
    while (deque.length && nums[i] > nums[deque[deque.length - 1]]) {
      deque.pop();
    }

    deque.push(i);

    // 检查队首元素是否超出窗口大小
    if (i - deque[0] >= k) {
      deque.shift();
    }

    // 当前窗口大小为 k 时，将队首元素添加到结果数组中
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }

  return result;
}

// function maxSlidingWindow2(nums: number[], k: number): number[] {
//   if (nums.length === 0) return [];
//   const res = [];
//   for (let i = 0; i <= nums.length - k; i++) {
//     let max = nums[i];
//     for (let j = i + 1; j < i + k; j++) {
//       max = Math.max(max, nums[j]);
//     }
//     res.push(max);
//   }
//   return res;
// };


// @lc code=end
```

## 240.搜索二维矩阵-ii

```typescript
/*
 * @lc app=leetcode.cn id=240 lang=typescript
 *
 * [240] 搜索二维矩阵 II
 */

// @lc code=start
//搜索空间缩减
function searchMatrix(matrix: number[][], target: number): boolean {
  const m = matrix.length
  const n = matrix[0].length
  let row = m - 1
  let col = 0
  // 从左下角开始找，缩写范围找
  // 比target大,证明在右边;比target小，证明在上边
  while (row>=0 && col<n) {
    if (matrix[row][col] === target) {
      return true
    } else if (matrix[row][col] > target) {
      row--
    } else {
      col++
    }
  }
  return false
};
// 暴力法，每一行二分查找
function searchMatrix2(matrix: number[][], target: number): boolean {
  const m = matrix.length
  const n = matrix[0].length

  for (let i = 0; i < m; i++) {
    let left = 0
    let right = n - 1
    while (left <= right) {
      const mid = (left + right) / 2
      if (matrix[i][mid] === target) {
        return true
      } else if (matrix[i][mid] > target) {
        right = mid-1
      } else {
        left = mid+1
      }
    }
  }
  return false
};
// @lc code=end
```

## 242.有效的字母异位词

```typescript
/*
 * @lc app=leetcode.cn id=242 lang=typescript
 *
 * [242] 有效的字母异位词
 */

// @lc code=start
function isAnagram(s: string, t: string): boolean {
  if (s.length !== t.length) return false
  const hash = {}
  for (const c of s) {
    hash[c] = (hash[c] || 0) + 1
  }
  for (const c of t) {
    if (!hash[c]) return false
    hash[c]--
  }
  return true
};
// @lc code=end
```

## 279.完全平方数

```typescript
/*
 * @lc app=leetcode.cn id=279 lang=typescript
 *
 * [279] 完全平方数
 */

// @lc code=start
function numSquares(n: number): number {
  // 创建一个动态规划数组，dp[i] 表示数字 i 最少能被几个完全平方数的和表示出来
  const dp = new Array(n + 1).fill(Number.MAX_SAFE_INTEGER)
  // 初始化 dp[0] 为 0
  dp[0] = 0
  // 遍历从 1 到 n 的每一个数字
  for (let i = 1; i <= n; i++) {
      // 对于每个数字，枚举所有小于它的完全平方数 j*j
    for (let j = 1; j * j <= i; j++) {
      // 状态转移方程：dp[i] = min(dp[i], dp[i - j*j] + 1)
      dp[i] = Math.min(dp[i],dp[i-j*j]+1)
    }
  }
  // 返回 dp[n]，即数字 n 最少能被几个完全平方数的和表示出来
  return dp[n]
};
// @lc code=end
```

## 283.移动零

```typescript
/*
 * @lc app=leetcode.cn id=283 lang=typescript
 *
 * [283] 移动零
 */

// @lc code=start
/**
 Do not return anything, modify nums in-place instead.
 */
function moveZeroes(nums: number[]): void {
  // 双指针解决
  let i = 0
  for (let j = 0; j < nums.length; j++) {
    //不为0的移动到前面，同时i++，这样最后的为0的就在最后面了
    if (nums[j] !== 0) {
      [nums[i], nums[j]] = [nums[j], nums[i]]
      i++
    }
  }
};
// @lc code=end
```

## 287.寻找重复数

```typescript
/*
 * @lc app=leetcode.cn id=287 lang=typescript
 *
 * [287] 寻找重复数
 */

// @lc code=start
function findDuplicate(nums: number[]): number {
  let slow = nums[0]; // 慢指针指向第一个元素
  let fast = nums[0]; // 快指针指向第一个元素

  // 使用快慢指针，类似于寻找链表中的环
  do {
    slow = nums[slow]; // 慢指针每次走一步
    fast = nums[nums[fast]]; // 快指针每次走两步
  } while (slow !== fast); // 直到慢指针和快指针相遇

  // 将快指针重新指向第一个元素
  fast = nums[0];

  // 快慢指针每次都走一步，直到它们相遇
  while (slow !== fast) {
    slow = nums[slow];
    fast = nums[fast];
  }

  return slow; // 返回重复的元素
}

function findDuplicate2(nums: number[]): number {
  // 排序
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length-1; i++) {
    if (nums[i] === nums[i + 1]) {
      return nums[i]
    }
  }
};
// @lc code=end
```

## 300.最长递增子序列

```typescript
/*
 * @lc app=leetcode.cn id=300 lang=typescript
 *
 * [300] 最长递增子序列
 */

// @lc code=start
function lengthOfLIS(nums: number[]): number {
  const n = nums.length
  // 特判
  if (n < 2) {
    return n;
  }
  // dp[i] 表示以 nums[i] 结尾的最长上升子序列的长度
  const dp = new Array(n).fill(1)
  // dp[0] = 1
  for (let i = 1; i < n; i++) {
   for (let j = 0; j < i; j++) {
     if (nums[j] < nums[i]) {
      dp[i] = Math.max(dp[i],dp[j]+1)
    }
   }
  }
  return Math.max(...dp)
};

function lengthOfLIS2(nums: number[]): number {
  const n = nums.length;
  // tails 存储所有最长上升子序列，初始化为第一个数
  const tails = [nums[0]];
  // 遍历 nums 数组，寻找最长上升子序列
  for (let i = 1; i < n; i++) {
    // 如果当前数比 tails 中的最后一个数还大，直接添加到 tails 中
    if (nums[i] > tails[tails.length - 1]) {
      tails.push(nums[i]);
    } else {
      // 否则使用二分查找找到第一个大于等于当前数的数的下标，替换掉它
      let left = 0, right = tails.length - 1;
      while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        if (tails[mid] < nums[i]) {
          left = mid + 1;
        } else {
          right = mid;
        }
      }
      tails[left] = nums[i];
    }
  }
  // 最终 tails 的长度就是最长上升子序列的长度
  return tails.length;
}

// @lc code=end
```

## 309.最佳买卖股票时机含冷冻期

```typescript
/*
 * @lc app=leetcode.cn id=309 lang=typescript
 *
 * [309] 最佳买卖股票时机含冷冻期
 */

// @lc code=start
function maxProfit(prices: number[]): number {
  const n = prices.length;
  if (n == 0) return 0;

  // 初始化状态转移数组
  const dp: number[][] = Array.from({ length: n }, () => [0, 0, 0]);

  // 初始化第一天的状态
  dp[0][0] = 0; // 不持有股票且没有进行过交易
  dp[0][1] = -prices[0]; // 持有股票
  dp[0][2] = 0; // 不持有股票但进行过一次买入交易

  // 从第二天开始遍历价格数组
  for (let i = 1; i < n; i++) {
    // 第i天不持有股票且没有进行过交易，状态转移方程
    // i-1天完成了一次交易交易，今天刚好处与冷却期
    // i-1天不持有
    // i-1天持有今天抛出就是dp[i][2]的情况，刚好完成一次交易，属于dp[i][2] = dp[i - 1][1] + prices[i]
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2]);

    // 第i天持有股票，状态转移方程
    // i-1天持有，或者昨天持有
    // i-1天不持有，今天持有
    // i-1天持有完成一次交易，则第i天是冷却期，不存在今天持有
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);

    // 第i天不持有股票但刚好进行过一次买入交易，状态转移方程
    // i - 1天持有今天抛出就是dp[i][2]的情况，刚好完成一次交易
    dp[i][2] = dp[i - 1][1] + prices[i];
  }

  // 返回最终的状态值
  return Math.max(dp[n - 1][0], dp[n - 1][2]);
};
// @lc code=end
```

## 322.零钱兑换

```typescript
/*
 * @lc app=leetcode.cn id=322 lang=typescript
 *
 * [322] 零钱兑换
 */

// @lc code=start
function coinChange(coins: number[], amount: number): number {
  const dp: number[] = new Array(amount + 1).fill(Infinity); // 初始化，凑出每个金额都需要的最小硬币数都为 Infinity
  dp[0] = 0 // 凑出 0 元不需要任何硬币
  for (let coin of coins) { // 遍历每个硬币
    for (let i = coin; i <= amount; i++) { // // 遍历每个金额
      dp[i] = Math.min(dp[i], dp[i - coin] + 1); // 状态转移方程
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
};
// @lc code=end
```

## 337.打家劫舍-iii

```typescript
/*
 * @lc app=leetcode.cn id=337 lang=typescript
 *
 * [337] 打家劫舍 III
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function rob(root: TreeNode | null): number {
  const robSub = (node: TreeNode | null): [number, number] => {
    if (node === null) {
      // j节点为空，抢和不抢收益都为零
      return [0,0]
    }
    // 递归左右子树
    const left = robSub(node.left)
    const right = robSub(node.right)
    // 抢当前节点的情况，等于当前节点+左右节点不抢的情况
    const rob = node.val + left[1] + right[1]
    // 不抢当前节点的情况，等于不抢当前节点+左右节点抢和不抢最大值相加的情况
    const notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1])
    // 返回抢和不抢的二维数组情况
    return [rob,notRob]
  }
  const result = robSub(root)
  // 比较跟节点抢和不抢的最大值情况
  return Math.max(...result)
};
// @lc code=end
```

## 338.比特位计数

```typescript
/*
 * @lc app=leetcode.cn id=338 lang=typescript
 *
 * [338] 比特位计数
 */

// @lc code=start
function countBits(num: number): number[] {
  const res: number[] = [0]; // 创建一个结果数组，初始值为 [0]。
  for (let i = 1; i <= num; i++) {
    if (i % 2 === 1) { // 如果 i 是奇数，那么 res[i] 等于 res[i-1] 的值加 1。
      res.push(res[i - 1] + 1);
    } else { // 如果 i 是偶数，那么 res[i] 等于 res[i/2] 的值。
      res.push(res[i / 2]);
    }
  }
  return res; // 返回结果数组。
}

function countBits2(n: number): number[] {
  const res: number[] = [0]
  const oneTotal = (n: number): number => {
    let count = 0
    while (n > 0) {
      // 奇数才+1
      if (n % 2 === 1) {
        count++
      }
      n = Math.floor(n / 2) // n/2 >> 或者n/2 | 0 都是向下取整的好方法
    }
    return count
  }
  for (let i = 1; i <= n; i++) {
    const count = oneTotal(i)
    res.push(count)
  }

  return res
};
// @lc code=end
```

## 344.反转字符串

```typescript
/*
 * @lc app=leetcode.cn id=344 lang=typescript
 *
 * [344] 反转字符串
 */

// @lc code=start
/**
 Do not return anything, modify s in-place instead.
 */
function reverseString(s: string[]): void {
  let left = 0
  let right = s.length-1
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]]
    left++
    right--
  }
};
// @lc code=end
```

## 347.前-k-个高频元素

```typescript
/*
 * @lc app=leetcode.cn id=347 lang=typescript
 *
 * [347] 前 K 个高频元素
 */

// @lc code=start
function topKFrequent(nums: number[], k: number): number[] {
  const map: Map<number, number> = new Map();
  const bucket: (Set<number> | undefined)[] = [];
  const result: number[] = [];
  for (const num of nums) {
    map.set(num, (map.get(num) || 0) + 1);
  }

  for (const [num, freq] of map) {
    bucket[freq] = (bucket[freq] || new Set<number>()).add(num);
  }
  for (let i = bucket.length - 1; i >= 0; i--) {
    if (bucket[i]) result.push(...bucket[i]!);
    if (result.length === k) break;
  }
  return result;
};
// @lc code=end
```

## 394.字符串解码

```typescript
/*
 * @lc app=leetcode.cn id=394 lang=typescript
 *
 * [394] 字符串解码
 */

// @lc code=start
function decodeString(s: string): string {
  // 如果是s是数字字符串直接返回'',例如s是'3'
  if(!isNaN(Number(s))) return ''
  const stack: string[] = []
  for (const c of s) {
    if (c === ']') {
      let str = ''
      // 累加[...]中括号的里面的字符
      while (stack.length && stack[stack.length - 1] !== '[') {
        str = stack.pop()+str
      }
      // 移除'['
      stack.pop()
      // 判断前面数字，然后累加次数
      let numStr = ''
      while (stack.length && !isNaN(Number(stack[stack.length-1]))) {
        numStr = stack.pop() +numStr
      }
      const num = Number(numStr)
      // 重复数字后的字符串
      stack.push(str.repeat(num))
    } else {
      stack.push(c)
    }
  }
  return stack.join('')
};
// @lc code=end
```

## 399.除法求值

```typescript
/*
 * @lc app=leetcode.cn id=399 lang=typescript
 *
 * [399] 除法求值
 */

// @lc code=start
type Graph = Record<string, Record<string, number>>;

function calcEquation(equations: string[][], values: number[], queries: string[][]): number[] {
  const res: number[] = []
  const graph: Graph = {}
  // 建立图
  for (let i = 0; i < equations.length; i++) {
    const [a, b] = equations[i]
    if (!graph[a]) graph[a] = {}
    if (!graph[b]) graph[b] = {}
    graph[a][b] = values[i]
    graph[b][a] = 1 / values[i]
  }
  for (const [src, dest] of queries) {
    if (!graph[src] || !graph[dest]) {
      res.push(-1)
      continue
    }
    const visited = new Set<string>()
    res.push(dfs(src, dest, visited, graph))
  }

  return res
};

function dfs(src: string, dest: string, visited: Set<string>, graph:Graph) {
  if (src === dest) {
    return 1
  }
  visited.add(src)
  for (const [neighbor, val] of Object.entries(graph[src])) {
    if (visited.has(neighbor)) continue
    const product = dfs(neighbor, dest, visited, graph)
    if (product !== -1) {
      return product * val
    }
  }
  return -1
}
// @lc code=end
```

## 406.根据身高重建队列

```typescript
/*
 * @lc app=leetcode.cn id=406 lang=typescript
 *
 * [406] 根据身高重建队列
 */

// @lc code=start
function reconstructQueue(people: number[][]): number[][] {
  const result:number[][] = []
  // 身高从高到底排序，身高相同按编号从低到高排序
  people.sort((a, b) => {
    if (a[0] !== b[0]) {
     return b[0]-a[0]
    } else {
      return a[1]-b[1]
    }
  })
  // 根据序号插入对应的位置
  for (const person of people) {
    result.splice(person[1], 0, person)
  }
  return result
  // 时间复杂度是 O(n ^ 2)，其中 n 是输入数组 people 的长度。
  //虽然代码中只有一个 for 循环，但在每次循环中，都会调用 splice 方法将元素插入到数组中，
  //这个方法的时间复杂度是 O(n)，因此总时间复杂度是 O(n ^ 2)。
};
// @lc code=end
```

## 416.分割等和子集

```typescript
/*
 * @lc app=leetcode.cn id=416 lang=typescript
 *
 * [416] 分割等和子集
 */

// @lc code=start
// 0-1背包
// 0 - 1 背包问题是一类经典的背包问题，它的定义如下：
/*有一个容量为 C 的背包，和 n 个物品，每个物品的重量为 w[i]，价值为 v[i]。需要在这些物品中选择一些装入背包中，使得装入的物品总重量不超过 C，且装入的物品总价值最大。
该问题可以用动态规划求解。定义一个二维数组 dp，其中 dp[i][j] 表示前 i 个物品装入容量为 j 的背包中所能获得的最大价值。对于第 i 个物品，有两种选择：
不选择第 i 个物品，则背包的价值为前 i - 1 个物品装入容量为 j 的背包中所能获得的最大价值，即 dp[i][j] = dp[i - 1][j]。
选择第 i 个物品，则背包的价值为前 i - 1 个物品装入容量为 j - w[i] 的背包中所能获得的最大价值加上第 i 个物品的价值，即 dp[i][j] = dp[i - 1][j - w[i]] + v[i]。
因此，最终状态转移方程为：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])。其中，dp[i - 1][j] 表示不选择第 i 个物品，背包的价值为前 i - 1 个物品装入容量为 j 的背包中所能获得的最大价值；dp[i - 1][j - w[i]] + v[i] 表示选择第 i 个物品，背包的价值为前 i - 1 个物品装入容量为 j - w[i] 的背包中所能获得的最大价值加上第 i 个物品的价值。
最终，dp[n][C] 就是所求的结果，即前 n 个物品装入容量为 C 的背包中所能获得的最大价值。
*/
function knapsack(C: number, w: number[], v: number[]): number {
  const n = w.length;

  // 初始化二维数组 dp
  // dp[i][j] 表示前 i 个物品装入容量为 j 的背包中所能获得的最大价值
  const dp: number[][] = new Array(n + 1).fill(null).map(() => new Array(C + 1).fill(0));

  // 动态规划求解
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= C; j++) {
      if (w[i - 1] > j) {
        // 背包容量不足，不能选择第 i 个物品
        dp[i][j] = dp[i - 1][j];
      } else {
        // 背包容量足够，可以选择第 i 个物品
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);
      }
    }
  }

  return dp[n][C];
}



function canPartition2(nums: number[]): boolean {
  const n = nums.length
  // 计算数组元素的总和
  const sum = nums.reduce((pre, cur) => pre + cur, 0)
  // 如果总和是奇数，无法分割成等和子集
  if (sum % 2 === 1) {
    return false
  }
  // 计算需要达到的等和子集的目标和
  const target = sum / 2
  // 存在元素比target大的元素，无法分割成等和子集
  const existGreaterTarget = nums.find(num => num > target)
  if (existGreaterTarget) return false
  // 初始化二维数组 dp
  // dp[i][j] 表示前 i 个元素能否组成和为 j 的子集。这里是n不是n+1，因为存在两个子集和相等
  const dp: boolean[][] = Array.from({ length: n }, () => new Array(target + 1).fill(false))
  // 初始化第一列
  // dp[0][0] 表示前 0 个元素组成和为 0 的子集，所以为 true
  dp[0][0] = true

  // 动态规划求解
  for (let i = 1; i < n; i++) {
    for (let j = 1; j <= target; j++) {
      if (nums[i] === j) {
        // 如果第 i 个元素等于 j，可以直接选第 i 个元素组成和为 j 的子集
        dp[i][j] = true
      } else if (nums[i] < j) {
        // 如果第 i 个元素小于 j，可以选择或不选择第 i 个元素
        // 如果不选择，继承前 i - 1 个元素的结果
        // 如果选择，需要组成和为 j - nums[i] 的子集，因此继承前 i - 1 个元素组成和为 j - nums[i] 的子集的结果
        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]
      } else {
        dp[i][j] = dp[i - 1][j]; // 不选择第 i 个元素，继承前 i - 1 个元素的结果
      }
    }
  }
  // 返回前 n-1个元素是否可以组成和为 target 的子集
  return dp[n-1][target]
};

function canPartition(nums: number[]): boolean {
  // 计算nums数组的总和
  const sum = nums.reduce((a, b) => a + b, 0);
  // 如果sum是奇数，就无法将数组分成两个子集，使得两个子集的元素和相等
  if (sum % 2 !== 0) {
    return false;
  }
  // 将数组分成两个子集，使得两个子集的元素和相等，等价于在nums数组中选择一些元素，使它们的和等于nums数组的一半
  const target = sum / 2;
  // 定义一个布尔类型的dp数组，其中dp[i]表示是否可以从nums数组中选择一些元素，使它们的和等于i
  const dp: boolean[] = [true];
  // 遍历nums数组中的每个元素
  for (const num of nums) {
    // 从target开始向下遍历dp数组
    for (let i = target; i >= num; i--) {
      // 如果dp[i - num]是true，那么dp[i]也是true
      dp[i] ||= dp[i - num]; // dp[i] = dp[i] || dp[i - num]
    }
  }
  // 返回dp[target]的值
  return dp[target] ?? false;
};



// @lc code=end
```

## 437.路径总和-iii

```typescript
/*
 * @lc app=leetcode.cn id=437 lang=typescript
 *
 * [437] 路径总和 III
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function pathSum(root: TreeNode | null, targetSum: number): number {
  let count = 0
  const dfs = (node: TreeNode| null,path:number[]) => {
    if (!node) return
    // 将当前节点的值添加到路径中
    path.push(node.val)
    let sum = 0
    // 从当前节点往前遍历路径，计算每个子路径的和
    for (let i = path.length - 1; i >= 0; i--) {
      sum += path[i]
      if (sum === targetSum) {
        // 如果子路径和等于目标和，则路径数量加一
        count++
      }
    }
    // 继续遍历左右子树，传递当前路径
    dfs(node.left, path)
    dfs(node.right, path)
    // 回溯，将当前节点的值从路径中删除
    path.pop()
  }
    // 从根节点开始深度优先遍历二叉树
  dfs(root, [])
  return count
};
// @lc code=end
```

## 438.找到字符串中所有字母异位词

```typescript
/*
 * @lc app=leetcode.cn id=438 lang=typescript
 *
 * [438] 找到字符串中所有字母异位词
 */

// @lc code=start
/**
 * @param {string} s - 输入字符串
 * @param {string} p - 模式字符串
 * @return {number[]} - 满足条件的子串起始位置数组
 */
function findAnagrams(s: string, p: string): number[] {
  // 定义变量存储结果数组和模式字符串的字符数量
  const res:number[] = [];
  const map = new Map<string, number>();

  // 遍历模式字符串，统计其中每个字符的数量
  for (const c of p) {
    map.set(c, (map.get(c) || 0) + 1);
  }

  let left = 0;
  let right = 0;
  let count = p.length;

  // 遍历输入字符串
  while (right < s.length) {
    const c = s[right];
    if (map.has(c) && map.get(c)! > 0) {
      // 如果当前字符在模式字符串中出现过，并且其数量大于 0
      count--;
    }
    map.set(c, (map.get(c) || 0) - 1);
    right++;

    if (count === 0) {
      // 如果子串中的字符数量都符合要求
      res.push(left);
    }

    if (right - left === p.length) {
      // 如果子串长度达到模式字符串的长度
      const c = s[left];
      if (map.has(c) && map.get(c)! >= 0) {
        // 如果当前字符在模式字符串中出现过，并且其数量大于等于 0
        count++;
      }
      map.set(c, (map.get(c) || 0) + 1);
      left++;
    }
  }

  return res;
}

// @lc code=end
```

## 461.汉明距离

```typescript
/*
 * @lc app=leetcode.cn id=461 lang=typescript
 *
 * [461] 汉明距离
 */

// @lc code=start
function hammingDistance(x: number, y: number): number {
  let xor = x ^ y; // 计算 x 和 y 的异或值
  let count = 0;

  // 统计异或值中 1 的个数
  while (xor !== 0) {
    if (xor & 1) { // 判断最低位是否为 1
      count++;
    }
    xor = xor >>> 1; // 右移一位，判断下一位
  }

  return count;
}

// @lc code=end
```

## 494.目标和

```typescript
/*
 * @lc app=leetcode.cn id=494 lang=typescript
 *
 * [494] 目标和
 */

// @lc code=start
function findTargetSumWays(nums: number[], target: number): number {
  // 创建一个Map，用于存储前i个数字组成的和为j的方案数
  const map = new Map<string, number>()
  const dfs = (i: number, j: number):number => {
    // 如果有缓存，直接返回
    const key = `${i}#${j}`
    if (map.has(key)) {
      return map.get(key)!
    }
     // 如果已经处理完所有数字，判断是否满足条件
    if (i === nums.length) {
      return j === 0 ? 1 : 0
    }
     // 对于每个数字，计算使用+或-符号的方案数之和
    const res: number = dfs(i + 1, j - nums[i]) + dfs(i + 1, j + nums[i])
    // 缓存结果，避免重复计算
    map.set(key,res)
    return res
  }
  // 从第一个数字开始递归
  return dfs(0, target)
}
// 斐波那契数 使用map添加缓存
function fibonacci(n: number): number {
  // 创建一个Map，用于存储已经计算过的斐波那契数列值
  const map = new Map<number, number>();

  function fib(n: number): number {
    if (n < 2) {
      return n;
    }
    // 如果已经计算过当前值，直接从Map中获取
    if (map.has(n)) {
      return map.get(n)!;
    }
    // 计算斐波那契数列值
    const res = fib(n - 1) + fib(n - 2);
    // 将计算结果存储到Map中
    map.set(n, res);
    return res;
  }

  // 从第0项开始计算斐波那契数列
  return fib(n);
}



function findTargetSumWays2(nums: number[], target: number): number {
  const n = nums.length
  const sum = nums.reduce((pre, cur) => pre + cur, 0)
  // 如果目标和大于所有元素的和，或者目标和和所有元素的和的奇偶性不同，则无解
  if (target > sum || (target + sum) % 2 !== 0) {
    return 0
  }
  if (Math.abs(target) > sum) {
    return 0;
  }
  const goal = (target + sum) / 2
  // dp[i][j] 表示前 i 个元素中选取若干个元素，使它们的和为 j 的方案数
  const dp = Array.from({ length: n + 1 }, () => new Array(goal + 1).fill(0))
  // 如果目标和为 0，则只有一种方案，即不选取任何元素
  dp[0][0] = 1
  for (let i = 1; i <= n; i++) {
    const num = nums[i - 1]
    for (let j = 0; j <= goal; j++) {
      dp[i][j] = dp[i - 1][j]
      if (num <= j) {
        dp[i][j] += dp[i - 1][j - num] // 不选取当前元素或选取当前元素
      }
    }
  }
  return dp[n][goal]

};
// @lc code=end
```

## 525.连续数组

```typescript
/*
 * @lc app=leetcode.cn id=525 lang=typescript
 *
 * [525] 连续数组
 */

// @lc code=start
function findMaxLength(nums: number[]): number {
  const hash = {};
  let max_length = 0;
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    const current = nums[i];
    if (current === 0) {
      // if the current element is 0, then we decrement the count
      count--;
    } else if (current === 1) {
      // if the current element is 1, then we increment the count
      count++;
    }

    if (count === 0) {
      // if the count is equal to o then we have a contiguous subarray of length equal to i+1
      max_length = i + 1;
    }
    if (count in hash) {

      max_length = Math.max(max_length, i - hash[count]); // update our max length
    } else {
      hash[count] = i;
    }

  }
  return max_length;
};
// @lc code=end
```

## 538.把二叉搜索树转换为累加树

```typescript
/*
 * @lc app=leetcode.cn id=538 lang=typescript
 *
 * [538] 把二叉搜索树转换为累加树
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function convertBST(root: TreeNode | null): TreeNode | null {
  let sum = 0
  function reverseInorderTraversal(node: TreeNode | null):void {
    // 如果节点为空，则直接返回
    if (!node) return
    // 先递归右子树
    reverseInorderTraversal(node.right)
     // 累加上前面节点的值和自身节点的值,更新当前节点的值
    sum += node.val
    node.val = sum
    // 递归遍历左子树
    reverseInorderTraversal(node.left)
  }
  // 调用辅助函数进行遍历，并返回根节点
  reverseInorderTraversal(root)
  return root
};
// @lc code=end
```

## 543.二叉树的直径

```typescript
/*
 * @lc app=leetcode.cn id=543 lang=typescript
 *
 * [543] 二叉树的直径
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function diameterOfBinaryTree(root: TreeNode | null): number {
  // 定义一个变量 maxDiameter 用于记录最大直径
  let maxDiameter = 0

  function dfs(node: TreeNode | null): number {
    if (!node) return 0

    // 递归左右子树的深度
    const left = dfs(node.left)
    const right = dfs(node.right)

    // 获取最大直径
    maxDiameter = Math.max(maxDiameter, left + right)

    // 返回深度，加上自身节点的深度1
    return Math.max(left, right) + 1
  }
  // 调用辅助函数计算深度，并返回最大直径
  dfs(root)
  return maxDiameter

};
// @lc code=end
```

## 560.和为-k-的子数组

```typescript
/*
 * @lc app=leetcode.cn id=560 lang=typescript
 *
 * [560] 和为 K 的子数组
 */
/**
*为什么如果前缀和减去 k 在 map 中出现过，则说明以当前位置为结尾的子数组和为 k
*如果前缀和减去 k 在 map 中出现过，则说明在之前的前缀和中有一个值等于当前前缀和减去 k。假设当前位置为 i，前缀和为 sum，前缀和减去 k 的值为 sum - k，则满足 sum - k 在 map 中出现过的条件为：
*sum - (sum - k) = k 在之前的前缀和中出现过。
*因此，以当前位置 i 为结尾的子数组中，存在一个子数组的和为 k，这个子数组的起始位置可以是之前任意一个位置 j（0 <= j < i），满足从 j 到 i 的子数组和为 k。因此，以当前位置 i 为结尾的符合要求的子数组的个数就等于之前前缀和中 sum - k 出现的次数。
*/

// @lc code=start
function subarraySum(nums: number[], k: number): number {
  // 创建一个 Map，用于存储前缀和及其出现的次数
  const map = new Map();
  // 初始化，将前缀和为 0 的情况出现次数设为 1
  map.set(0, 1);

  // 定义变量 sum 和 count，分别表示当前的前缀和和符合要求的子数组个数
  let sum = 0;
  let count = 0;

  // 遍历数组 nums 中的每个元素
  for (let num of nums) {
    // 更新前缀和
    sum += num;

    // 如果前缀和减去 k 在 map 中出现过，则说明以当前位置为结尾的子数组和为 k
    if (map.has(sum - k)) {
      // 累加符合要求的子数组个数
      count += map.get(sum - k);
    }

    // 将当前前缀和及其出现次数加入 map 中
    map.set(sum, (map.get(sum) || 0) + 1);
  }

  // 返回符合要求的子数组个数
  return count;
};
// @lc code=end
```

## 581.最短无序连续子数组

```typescript
/*
 * @lc app=leetcode.cn id=581 lang=typescript
 *
 * [581] 最短无序连续子数组
 */

// @lc code=start
function findUnsortedSubarray(nums: number[]): number {
  const n = nums.length
  let l = 0
  let r = n - 1
  // 从左往右找到第一个不是按升序的元素
  while (l < n - 1 && nums[l] <= nums[l + 1]) {
    l++
  }
  // 数组已经有序，直接返回 0
  if (l === n - 1) {
    return 0;
  }
  // 从右往左找到第一个不是降序的元素
  while (r > 0 && nums[r - 1] <= nums[r]) {
    r--
  }
  // 找l~r之间的最小值和最大值
  let minNum = Infinity 
  let maxNum = -Infinity
  for (let i = l; i <= r; i++) {
    minNum = Math.min(minNum,nums[i])
    maxNum = Math.max(maxNum, nums[i])
  }

  // 向左扩展 l，直到找到第一个大于 minNum 的位置
  while (l >= 0 && nums[l] > minNum) {
    l--
  }
  
  // 向右扩展 r，直到找到第一个小于 maxNum 的位置
  while (r < n  && nums[r] < maxNum) {
    r++
  }

  return r - l - 1
};
// @lc code=end
```

## 617.合并二叉树

```typescript
/*
 * @lc app=leetcode.cn id=617 lang=typescript
 *
 * [617] 合并二叉树
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
  // 如果没有节点，直接返回另一个节点
  if (!root1) return root2
  if (!root2) return root1
  // 新建节点并，值为两个根节点的值之和
  const mergeTree = new TreeNode(root1.val + root2.val)
  // 递归左节点
  mergeTree.left = mergeTrees(root1.left, root2.left)
  // 递归右节点
  mergeTree.right = mergeTrees(root1.right, root2.right)
  
  return mergeTree
};
// @lc code=end
```

## 621.任务调度器

```typescript
/*
 * @lc app=leetcode.cn id=621 lang=typescript
 *
 * [621] 任务调度器
 */

// @lc code=start
function leastInterval(tasks: string[], n: number): number {
  const taskCounts = new Map<string, number>(); // 使用 Map 记录每个任务出现的次数
  let maxCount = 0; // 出现次数最多的任务的个数
  let maxTaskCount = 0; // 出现次数最多的任务的出现次数

  for (const task of tasks) {
    const count = (taskCounts.get(task) ?? 0) + 1; // 获取任务的出现次数
    taskCounts.set(task, count); // 更新任务的出现次数
    if (count > maxTaskCount) { // 如果当前任务的出现次数超过了出现次数最多的任务的出现次数
      maxTaskCount = count;
      maxCount = 1;
    } else if (count === maxTaskCount) { // 如果当前任务的出现次数等于出现次数最多的任务的出现次数
      maxCount++;
    }
  }
  
  return Math.max(tasks.length, (maxTaskCount - 1) * (n + 1) + maxCount);

};
// @lc code=end
```

## 647.回文子串

```typescript
/*
 * @lc app=leetcode.cn id=647 lang=typescript
 *
 * [647] 回文子串
 */

// @lc code=start
function countSubstrings(s: string): number {
  let count = 0;
  for (let i = 0; i < s.length; i++) {
    expand(i, i) // 奇数长度的回文子串
    expand(i, i + 1) // 偶数长度的回文子串
  }
  return count
  // 定义扩展函数expand
  function expand(l:number, r:number) {
    while (l >= 0 && r < s.length && s[l] === s[r]) { // 当左右指针指向字符相等时，继续扩展

      count++ // 增加回文子串计数器
      l-- // 向左扩展
      r++ // 向右扩展
    }
  }
};



// @lc code=end
```

## 713.乘积小于-k-的子数组

```typescript
/*
 * @lc app=leetcode.cn id=713 lang=typescript
 *
 * [713] 乘积小于 K 的子数组
 */

// @lc code=start
function numSubarrayProductLessThanK(nums: number[], k: number): number {
  if (k <= 1) return 0
  let left = 0
  let right = 0
  let res = 0
  let target = 1
  while (right < nums.length) {
    target *= nums[right]
    while (target >= k) {
      target /= nums[left]
      left++
    }
    res += right - left + 1
    right++
  }
  return res
};
// @lc code=end
```

## 739.每日温度

```typescript
/*
 * @lc app=leetcode.cn id=739 lang=typescript
 *
 * [739] 每日温度
 */

// @lc code=start
function dailyTemperatures(temperatures: number[]): number[] {

  const stack: number[] = []
  // 初始化气温列表，默认值为0
  const res = new Array(temperatures.length).fill(0)
  for (let i = 0; i < temperatures.length; i++) {
    //将栈顶元素下标对应的值和当前元素进行比较
    while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
      const idx = stack.pop() as number
      res[idx] = i-idx
    }
    stack.push(i)
  }
  return res
};
// @lc code=end
```

## 763.划分字母区间

```typescript
/*
 * @lc app=leetcode.cn id=763 lang=typescript
 *
 * [763] 划分字母区间
 */

// @lc code=start
function partitionLabels(s: string): number[] {
  let res: number[] = []
  let maxIndex = 0
  let start = 0
  // 记录每个字符出现的最大索引
  const map = new Map<string, number>()
  for (let i = 0; i < s.length; i++) {
    map.set(s[i],i)
  }
  for (let i = 0; i < s.length; i++) {
    // 更新当前片段出现字符的最大索引
    maxIndex = Math.max(maxIndex, map.get(s[i])!)
    
    // 如果当前索引等于最大索引，切割
    if (maxIndex === i) {
      res.push(i - start + 1)
      start = i+1
    }
  }
  return res
};
// @lc code=end
```

## 921.使括号有效的最少添加

```typescript
/*
 * @lc app=leetcode.cn id=921 lang=typescript
 *
 * [921] 使括号有效的最少添加
 */

// @lc code=start
function minAddToMakeValid(s: string): number {
  const stack:string[]= []
  for (let i = 0; i < s.length; i++) {
    // 如果是)并且绽的最后一个元素是(匹配，则出栈
    if (s[i] === ')' && stack[stack.length - 1] === '(') stack.pop()
    else stack.push(s[i])
  }
  return stack.length
};
// @lc code=end
```

## 925.长按键入

```typescript
/*
 * @lc app=leetcode.cn id=925 lang=typescript
 *
 * [925] 长按键入
 */

// @lc code=start
function isLongPressedName(name: string, typed: string): boolean {
  let j = 0 // 初始化 name 的索引为 0
  for (let i = 0; i < typed.length; i++) {
    // 如果当前字符相同，将 name 的索引加 1
    if (typed[i] === name[j]) {
      j++
      // 如果当前字符与 name 的前一个字符相同，继续扫描 typed
    } else if (typed[i] === name[j - 1]) {
      continue
    } else {
      // 如果当前字符与 name 中的字符不同且与 name 前一个字符也不同，返回 false
      return false
    }
  }
  // 如果扫描完 typed 后，name 的索引等于 name 的长度，返回 true，否则返回 false
  return j === name.length
};
// @lc code=end
```

## 946.验证栈序列

```typescript
/*
 * @lc app=leetcode.cn id=946 lang=typescript
 *
 * [946] 验证栈序列
 */

// @lc code=start
function validateStackSequences(pushed: number[], popped: number[]): boolean {
  const stack: number[] = []
  for (const cur of pushed) {
    stack.push(cur)
    // 和出栈元素进行比对，如果匹配都弹出栈
    while (stack[stack.length - 1] === popped[0] && stack.length) {
      stack.pop()
      popped.shift()
    }
  }
  return !stack.length

};
// @lc code=end
```

## 1190.反转每对括号间的子串

```typescript
/*
 * @lc app=leetcode.cn id=1190 lang=typescript
 *
 * [1190] 反转每对括号间的子串
 */

// @lc code=start
function reverseParentheses(s: string): string {
  const stack:string[] = [""]
  for (const c of s) {
    if (c === '(') stack.push("")
    else if (c === ')') {
      const str = stack.pop()?.split("").reverse().join("")
      stack[stack.length - 1] += str
    } else {
      stack[stack.length-1]+= c
    }
  }
  return stack.pop() as string
};
// @lc code=end
```

## 1249.移除无效的括号

```typescript
/*
 * @lc app=leetcode.cn id=1249 lang=typescript
 *
 * [1249] 移除无效的括号
 */

// @lc code=start
function minRemoveToMakeValid(s: string): string {
  const arr = [...s] // 将字符串转化为字符数组
  const stack: number[] = [] // 定义栈，用于存储未匹配的左括号 '(' 的下标

  // 第一遍扫描，找出未匹配的左括号，并将其下标存入栈中
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === '(') { // 如果当前字符为左括号 '('，将其下标存入栈中
      stack.push(i)
    } else if (arr[i] === ')') { // 如果当前字符为右括号 ')'
      if (stack.length) { // 如果栈非空，说明当前右括号匹配到了一个左括号
        stack.pop() // 弹出栈顶的左括号
      } else { // 如果栈为空，说明当前右括号没有匹配的左括号，将其替换为空字符串
        arr[i] = ''
      }
    }
  }
  // 第二遍扫描，将剩余未匹配的左括号替换为空字符串
  for (const i of stack) {
    arr[i] = ''
  }
  return arr.join('') // 将字符数组转化为字符串并返回
};
// @lc code=end
```

